;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Git Interface
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jiri.git-interface jazz


(import (jazz.git.foreign)
        (jazz.git.interface)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.ui.window)
        (jiri.git)
        (jiri.settings)
        (jiri.structure)
        (jiri.view)
        (jiri.window)
        (jiri.work))


;;;
;;;; Pull
;;;


(definition public (pull-repository title url branch password dir step of head mid tail cont)
  (define (open/init-repository proc)
    (let ((existing? (file-exists? dir)))
      (cond (existing?
             (let ((repo (git-repository-open dir)))
               (proc repo (git-remote-lookup repo "origin"))))
            (else
             (let ((repo (git-repository-init dir)))
               (proc repo (git-remote-create repo "origin" url)))))))
  
  (set-cursor :wait)
  (set-work-in-progress? #t)
  (set-title~ status-view (downloading-title title step of))
  (git-callback-hwnd (get-handle~ (get-toplevel)))
  (open/init-repository
    (lambda (repo remote)
      (let ((megabytes 0))
        (git-remote-connect-with-retries remote #f)
        (set-download-progress
          (let ((inited? #f))
            (lambda (result)
              (git-download-state
                (lambda (total-objects received-objects received-bytes)
                  (let ((percentage (* (percentage received-objects total-objects) (- mid head)))
                        (downloaded (fxfloor (/ (exact->inexact received-bytes) (* 1024. 1024.))))
                        (remaining (- total-objects received-objects)))
                    (let ((effective-percentage (fxround (+ work-percentage percentage))))
                      (set-title~ percentage-view (string-append (number->string effective-percentage) "%"))
                      (set-title~ downloaded-view (string-append "Downloaded: " (number->string (+ work-downloaded downloaded)) "M"))
                      (set-title~ remaining-view (string-append "Remaining: " (number->string remaining)))
                      (set! megabytes downloaded)))
                  (when (not inited?)
                    (set-info~ progress-view (new Range head mid) (new Range 0 total-objects))
                    (set! inited? #t))
                  (set-pos~ progress-view received-objects))))))
        (set-download-done
          (lambda (result)
            (safe-quit-point)
            (git-check-error result)
            (set-work-percentage (* mid 100.))
            (set-work-downloaded (+ work-downloaded megabytes))
            (set-title~ status-view (installing-title title step of))
            (set-info~ progress-view (new Range head mid) (new Range 0 10))
            (set-pos~ progress-view 10)
            (git-remote-disconnect remote)
            (git-remote-update-tips remote)
            (git-remote-free remote)
            (git-repository-set-head repo (string-append "refs/heads/" branch))
            (let ((upstream (git-reference-lookup repo (string-append "refs/remotes/origin/" branch))))
              (let ((commit (git-object-lookup repo (git-reference->id repo upstream) GIT_OBJ_COMMIT)))
                (unless (git-branch-lookup repo branch GIT_BRANCH_LOCAL)
                  (git-branch-create repo branch commit 1))
                (let ((new-content? #f))
                  (set-checkout-progress
                    (let ((inited? #f))
                      (lambda (result)
                        ;; from a discusion on freenode, aborting a checkout could leave the worktree in an arbitrary
                        ;; state, but the next checkout force should overwrite whatever is present in the worktree...
                        (safe-quit-point)
                        (git-checkout-state
                          (lambda (path completed-steps total-steps)
                            (when (> total-steps 0)
                              (set! new-content? #t)
                              (let ((percentage (* (percentage completed-steps total-steps) (- tail mid)))
                                    (remaining (- total-steps completed-steps)))
                                (let ((effective-percentage (fxround (+ work-percentage percentage))))
                                  (set-title~ percentage-view (string-append (number->string effective-percentage) "%"))
                                  (set-title~ remaining-view (string-append "Remaining: " (number->string remaining)))))
                              (when (not inited?)
                                (set-info~ progress-view (new Range mid tail) (new Range 0 total-steps))
                                (set! inited? #t))
                              (set-pos~ progress-view completed-steps)))))))
                  (set-checkout-done
                    (lambda (result)
                      (safe-quit-point)
                      (git-check-error result)
                      (set-work-percentage (* tail 100.))
                      (set-info~ progress-view (new Range mid tail) (new Range 0 10))
                      (set-pos~ progress-view 10)
                      (git-reference-free upstream)
                      (git-object-free commit)
                      (git-repository-free repo)
                      (cont new-content?)))
                (git-checkout-head-force-threaded repo))))))
        (git-remote-download-threaded remote)))))


(define (downloading-title title step of)
  (string-append "Downloading " title " (" (number->string step) "/" (number->string of) ")"))


(define (installing-title title step of)
  (string-append "Installing " title " (" (number->string (+ step 1)) "/" (number->string of) ")"))


;;;
;;;; Remote
;;;


(definition public (git-remote-connect-with-retries remote cancel)
  (let ((password #f))
    (define (ask-password)
      (set! password (or (closed-beta-password) (message-box "Yownu closed-alpha contains copyrighted data.\r\n\r\nBy installing this program you agree to not redistribute it in whole or in part, including screenshots and videos.")))
      (or password
          (cancel-connection)))
    
    (define (cancel-connection)
      (if cancel
          (begin
            (set-cursor :arrow)
            (set-work-in-progress? #f)
            (continuation-return cancel))
        (exit 1)))
    
    (git-remote-setup-callbacks remote
      (new Git-Callbacks
        credentials-callback: (lambda ()
                                (git-cred-userpass-plaintext-new (jiri-username) (ask-password)))))
    (let ((max-tries 3))
      (let loop ((try 1))
        (if (> try max-tries)
            (exit 1)
          (catch (Git-Exception exc
                   (let ((err (get-message~ exc)))
                     (define (debug-info)
                       (if (jiri-development?)
                           (string-append " (" (git-remote-url remote) ")")
                         ""))
                     
                     (cond ((string-ends-with? err "401")
                            (message-box "Incorrect password")
                            (loop (+ try 1)))
                           (else
                            (message-box (string-append "Unable to connect to server" (debug-info) ":\n\n" err))
                            (cancel-connection)))))
            (git-remote-connect remote GIT_DIRECTION_FETCH)
            (closed-beta-password password)))))))


;;;
;;;; Callback
;;;


(set-notification-callback
  (lambda (what result)
    (cond ((= what DOWNLOAD_PROGRESS) (download-progress result))
          ((= what DOWNLOAD_DONE)     (download-done     result))
          ((= what CHECKOUT_PROGRESS) (checkout-progress result))
          ((= what CHECKOUT_DONE)     (if (in-modal?)
                                          (delay-modal-user-event what result)
                                        (checkout-done result)))
          ((= what UPDATING_GAME)     (unless work-done?
                                        (set-title~ stage-view "Updating game"))))))


;;;
;;;; Quit
;;;


(define quit-requested?
  #f)


(definition public (quit-confirm-abort title)
  (lambda ()
    (if (not work-in-progress?)
        (exit)
      (let ((code (message-box (string-append title " in progress.\n\nDo you want to abort?") type: 'question)))
        (when (eq? code 'yes)
          (request-quit "Aborting..."))))))


(definition public (quit-safely)
  (lambda ()
    (if (not work-in-progress?)
        (exit)
      (request-quit "Disconnecting..."))))


(define (request-quit title)
  (set! quit-requested? #t)
  (git-request-quit)
  (set-cursor :wait)
  (set-title~ status-view title)
  (when minimize-view
    (set-enabled?~ minimize-view #f))
  (when close-view
    (set-enabled?~ close-view #f)))


(define (safe-quit-point)
  (when quit-requested?
    (exit))))
