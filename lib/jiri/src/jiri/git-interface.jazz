;;;==============
;;;  JiriScheme
;;;==============
;;;
;;;; Git Interface
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  See www.jazzscheme.org for details.


(module jiri.git-interface jazz


(import (jazz.application)
        (jazz.git.foreign)
        (jazz.git.interface)
        (jazz.graphic)
        (jazz.jml)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.ui.window)
        (jiri.git)
        (jiri.manage)
        (jiri.settings)
        (jiri.structure)
        (jiri.window)
        (jiri.work))


;;;
;;;; Pull
;;;


(definition public (pull-repository section password dir cont (remote-exception? #f))
  (let ((title (get-title~ section))
        (connection (get-connection~ section)))
    (let ((id (get-id~ connection))
          (name (get-name~ connection))
          (url (get-url~ connection))
          (branch (get-branch~ connection))
          (download-task (get-download-task~ connection))
          (checkout-task (get-checkout-task~ connection)))
      (define (open/init-repository proc)
        (let ((existing? (file-exists? dir)))
          (cond (existing?
                  (let ((repo (git-repository-open dir)))
                    (proc repo (git-remote-lookup repo "origin"))))
                (else
                 (let ((repo (git-repository-init dir)))
                   (proc repo (git-remote-create repo "origin" url)))))))
      
      (set-cursor :wait)
      (set-started?~ connection #t)
      (set-working?~ connection #t)
      (set-status~ download-task (string-append "Downloading " title))
      (git-callback-hwnd (get-handle~ (get-toplevel)))
      (open/init-repository
        (lambda (repo remote)
          (git-remote-connect-with-retries connection remote #f remote-exception?)
          (set-range~ download-task (new Range 0 1))
          (set-download-progress~ connection
            (let ((inited? #f))
              (lambda (result)
                (git-download-state id
                  (lambda (total-objects received-objects received-bytes)
                    (let ((downloaded (fxfloor (/ (exact->inexact received-bytes) (* 1024. 1024.))))
                          (remaining (- total-objects received-objects)))
                      (set-downloaded~ download-task downloaded)
                      (set-remaining~ download-task remaining))
                    (when (not inited?)
                      (set-range~ download-task (new Range 0 total-objects))
                      (set! inited? #t))
                    (set-pos~ download-task received-objects))))))
          (set-download-done~ connection
            (lambda (result)
              (unless (safe-abort-point
                        (lambda ()
                          (git-remote-disconnect remote)
                          (git-remote-free remote)
                          (git-repository-free repo)
                          (set-cursor :arrow)
                          (set-working?~ connection #f)))
                (git-check-error result)
                (set-status~ checkout-task (string-append "Installing " title))
                (set-done~ download-task)
                (git-remote-disconnect remote)
                (git-remote-update-tips remote)
                (git-remote-free remote)
                (git-repository-set-head repo (string-append "refs/heads/" branch))
                (let ((upstream (git-reference-lookup repo (string-append "refs/remotes/origin/" branch))))
                  (let ((commit (git-object-lookup repo (git-reference->id repo upstream) GIT_OBJ_COMMIT)))
                    (define (checkout-cleanup)
                      (git-reference-free upstream)
                      (git-object-free commit)
                      (git-repository-free repo)
                      (set-cursor :arrow)
                      (set-working?~ connection #f))
                    
                    (unless (git-branch-lookup repo branch GIT_BRANCH_LOCAL)
                      (git-branch-create repo branch commit 1))
                    (let ((new-content? #f))
                      (set-range~ checkout-task (new Range 0 1))
                      (set-checkout-progress~ connection
                        (let ((inited? #f))
                          (lambda (result)
                            ;; from a discusion on freenode, aborting a checkout could leave the worktree in an arbitrary
                            ;; state, but the next checkout force should overwrite whatever is present in the worktree...
                            ;; commented out as there is no way to interrupt the threaded checkout
                            ;; (safe-abort-point checkout-cleanup)
                            (git-checkout-state id
                              (lambda (path completed-steps total-steps)
                                (when (> total-steps 0)
                                  (set! new-content? #t)
                                  (let ((remaining (- total-steps completed-steps)))
                                    (set-remaining~ checkout-task remaining))
                                  (when (not inited?)
                                    (set-range~ checkout-task (new Range 0 total-steps))
                                    (set! inited? #t))
                                  (set-pos~ checkout-task completed-steps)))))))
                      (set-checkout-done~ connection
                        (lambda (result)
                          (unless (safe-abort-point checkout-cleanup)
                            (git-check-error result)
                            (set-done~ checkout-task)
                            (checkout-cleanup)
                            (cont new-content?))))
                      (git-reset-hard-threaded id repo commit)))))))
          (git-remote-download-threaded id remote))))))


;;;
;;;; Remote
;;;


(class Password-Box extends Message-Box
  
  
  (method override (focus-box)
    (acquire-focus~ (locate~ user-content 'password)))
  
  
  (method override (get-modal-result)
    (get-string-content~ (locate~ user-content 'password))))


(class Password-Border extends Border-View
  
  
  (form
    (<install>                                 border-type: solid border-color: {Color Entry-Border}
      (<Scroller-View>          name: scroller hscroll?: #f vscroll?: #f
        (<!>                    name: content  layout-type: fill
          (<Password-Text-View> name: password return-press-handler: {Event-Handler :form on-return-press} escape-press-handler: {Event-Handler :form on-escape-press})))))
  
  
  (method override (on-return-press evt)
    (process-action~ (child~ (get-guest) 'yes) self))
  
  
  (method override (on-escape-press evt)
    (process-action~ (child~ (get-guest) 'cancel) self)))


(definition public (password-dialog)
  (let ((content (new Password-Border size: {Dimension 460 21})))
    (let ((password (locate~ content 'password))
          (code (catch (Cancel-Signal exc
                         'cancel)
                  (message-box
                    (or (jiri-password-message) `(<span> (<paragraph> "Please enter your password:")))
                    class: Password-Box
                    type: 'error
                    title: (or (jiri-password-title) "Password")
                    yes: (or (jiri-password-yes) "OK")
                    content: content
                    content-spacing: 2
                    sound: #f))))
      (when (eq? code 'yes)
        (get-string-content~ password)))))


(definition public (git-remote-connect-with-retries connection remote cancel (remote-exception? #f))
  (let ((password #f))
    (define (ask-password)
      (set! password (or (current-password) (password-dialog)))
      (or password
          (cancel-connection)))
    
    (define (cancel-connection)
      (if cancel
          (begin
            (set-cursor :arrow)
            (set-working?~ connection #f)
            (continuation-return cancel))
        (exit 1)))
    
    (git-remote-setup-callbacks remote
      (new Git-Callbacks
        credentials-callback: (lambda ()
                                (with-gambit-os-interrupts
                                  (lambda ()
                                    (git-cred-userpass-plaintext-new (jiri-username) (or (jiri-password) (ask-password))))))))
    (let ((max-tries 3))
      (let loop ((try 1))
        (if (> try max-tries)
            (exit 1)
          (catch (Git-Exception exc
                   (let ((err (get-message~ exc)))
                     (cond ((string-ends-with? err "401")
                            (message-box "Incorrect password")
                            (loop (+ try 1)))
                           (else
                            (if remote-exception?
                                (begin
                                  (set-cursor :arrow)
                                  (set-working?~ connection #f)
                                  (throw exc))
                              (message-box (if (jiri-devel?)
                                               (string-append "Unable to connect to server (" (git-remote-url remote) "):\n\n" err)
                                             "Unable to connect to server"))
                              (exit 1))))))
            (git-remote-connect remote GIT_DIRECTION_FETCH)
            (current-password password)))))))


;;;
;;;; Callback
;;;


(definition (notification-callback-function id what result)
  (let ((connection (id->connection id)))
    (cond ((= what DOWNLOAD_PROGRESS) ((get-download-progress~ connection) result))
          ((= what DOWNLOAD_DONE)     ((get-download-done~ connection)     result))
          ((= what CHECKOUT_PROGRESS) ((get-checkout-progress~ connection) result))
          ((= what CHECKOUT_DONE)     (if (in-modal?)
                                          (delay-modal-user-event id what result)
                                        ((get-checkout-done~ connection) result))))))


(set-notification-callback notification-callback-function)


;;;
;;;; Quit
;;;


(definition public (quit-confirm-abort title)
  (lambda ()
    (if (not (work-in-progress?))
        (exit)
      (let ((code (message-box (string-append title " in progress.\n\nDo you want to abort?") type: 'question)))
        (when (eq? code 'yes)
          (request-quit "Aborting..."))))))


(definition public (quit-safely)
  (lambda ()
    (if (not (work-in-progress?))
        (exit)
      (request-quit "Disconnecting..."))))


(define (request-quit title)
  (set-abort-requested (lambda () (exit)))
  (git-request-abort)
  (set-title~ status-view title)
  (when minimize-view
    (set-enabled?~ minimize-view #f))
  (when close-view
    (set-enabled?~ close-view #f))))
