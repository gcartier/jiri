;;;==============
;;;  JiriScheme
;;;==============
;;;
;;;; Install
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  See www.jazzscheme.org for details.


(module jiri.install jazz


@CONVERT (
(import (jazz.event)
        (jazz.git.foreign)
        (jazz.io)
        (jazz.settings)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (jiri)
        (jiri.base)
        (jiri.git)
        (jiri.monitor)
        (jiri.platform)
        (jiri.view)
        (jiri.section)
        (jiri.settings)
        (jiri.structure)
        (jiri.task)
        (jiri.window)
        (jiri.work))


(define stage
  #f)


(define (jiri-prepare)
  (current-root-dir (string-argument "root-dir" #f))
  (current-password (string-argument "password" #f))
  (called-from (string-argument "called-from" #f))
  (set! stage (cond ((and (current-root-dir)
                          (equal? (called-from) "setup"))
                     'install-from-setup)
                    ((and (current-root-dir)
                          (equal? (called-from) "root"))
                     'install-from-root)
                    ((and (current-root-dir)
                          (equal? (called-from) "current"))
                     'install-from-current)
                    (else
                     (message-box "It is incorrect to launch this application")
                     (exit 1))))
  (when (neq? stage 'install-from-root)
    (set-work-downloaded (integer-argument "work-downloaded" 0))
    (set-window-h (integer-argument "window-h" -1))
    (set-window-v (integer-argument "window-v" -1))
    (set-send-ready? (boolean-argument "send-ready" #f))))


;;;
;;;; Install
;;;


(define (jiri-install)
  (case stage
    ((install-from-setup) (install-from-setup))
    ((install-from-root) (install-from-root))
    ((install-from-current) (install-from-current))))


(define (install-tasks-done)
  (for-each set-done (get-children (get-connection (jiri-install-section)))))


(define (transfer-tasks-setup proc)
  (let ((section (jiri-transfer-section)))
    (bind (current-task root-task) (get-tasks section)
      (proc current-task root-task))))


(define (work-offline)
  (bell)
  (set-cursor :arrow)
  (set-title stage-view "Unable to connect to server")
  (if (file-exists? (app-exe))
      (begin
        (set-work-done? #t)
        (set-color stage-view stage-install-color)
        (set-enabled? play-view #t))
    (set-color stage-view stage-setup-color)
    (set-title play-view "Not found")
    (set-enabled? play-view #f)))


;;;
;;;; Install From Setup
;;;


(define (install-from-setup)
  (catch (Git-Exception exc
           (if (jiri-offline?)
               (work-offline)
             (exit 1)))
    (set-cursor :wait)
    (install-tasks-done)
    (transfer-tasks-setup
      (lambda (current-task root-task)
        (install-current current-task
          (lambda ()
            (install-root root-task
              (lambda ()
                (install-platform)
                (update-start-menu)
                (install-uninstall)
                (install-app/data
                  (lambda (new-content?)
                    (install-done)))))))))))


;;;
;;;; Install From Root
;;;


(define (install-from-root)
  (catch (Git-Exception exc
           (if (jiri-offline?)
               (work-offline)
             (exit 1)))
    (pull-repository (jiri-install-section) (current-password) (install-dir)
      (lambda (new-content?)
        (if new-content?
            (delegate-install (current-root-dir) (current-password) "current")
          (begin
            (send-crash-reports)
            (update-start-menu)
            (rewind-start-menu)
            (transfer-tasks-setup
              (lambda (current-task root-task)
                (set-done current-task)
                (set-done root-task)
                (install-app/data
                  (lambda (new-content?)
                    (install-done))))))))
      #t)))


;;;
;;;; Install From Current
;;;


(define (install-from-current)
  (catch (Git-Exception exc
           (if (jiri-offline?)
               (work-offline)
             (exit 1)))
    (set-cursor :wait)
    (start-send-crash-reports)
    (install-tasks-done)
    (transfer-tasks-setup
      (lambda (current-task root-task)
        (install-current current-task
          (lambda ()
            (install-root root-task
              (lambda ()
                (update-start-menu)
                (rewind-start-menu)
                (install-app/data
                  (lambda (new-content?)
                    (install-done)))))))))))


;;;
;;;; Work
;;;


(define (install-app/data cont)
  (pull-repository (jiri-app-section) (current-password) (app-dir)
    (lambda (new-content?)
      (cond ((data-dir)
             (pull-repository (jiri-data-section) (current-password) (data-dir)
               cont
               #t))
            ((jiri-data-work)
             ((jiri-data-work) (jiri-data-section) 5 6 cont))))
    #t))


;;;
;;;; Done
;;;


(define (install-done)
  (set-title stage-view (or (jiri-play-ready) "Ready to play!"))
  (set-color stage-view stage-ready-color)
  (set-title status-view "Done")
  (set-cursor :arrow)
  (set-work-done? #t))


(define (count-zero-deep dir (ignore: ignore #f))
  (let ((count 0))
    (iterate-directory dir
      (lambda (path)
        (let ((filename (get-name path)))
          (unless (or (filename=? filename ".git")
                      (and ignore
                           (member? filename ignore
                             test: filename=?)))
            (increase! count))))
      files?: #t
      directories?: #t
      recursive?: #f)
    count))


(define (count-one-deep dir)
  (let ((count 0))
    (iterate-directory dir
      (lambda (path)
        (increase! count)
        (when (and (directory? path)
                   (not (filename=? (get-name path) ".git")))
          (iterate-directory path
            (lambda (path)
              (increase! count))
            files?: #t
            directories?: #t
            recursive?: #f)))
      files?: #t
      directories?: #t
      recursive?: #f
      ignored-toplevel-dirnames: '(".git"))
    count))


(define (install-current task cont)
  (let ((install-dir (make-directory (install-dir)))
        (current-dir (make-directory (current-dir))))
    (set-range task (new Range 0 (count-one-deep install-dir)))
    (thread-start!
      (new-thread
        (lambda ()
          (let ((first? #t))
            (install-directory install-dir current-dir
              filter: (lambda (action pathname)
                        (if (and (eq? action 'copy)
                                 (pathname=? (get-parent pathname) install-dir)
                                 (filename=? (get-name pathname) ".git"))
                            #f
                          #t))
              feedback: (lambda (action pathname)
                          (let ((parent (get-parent pathname)))
                            (when (or (pathname=? parent install-dir)
                                      (pathname=? (get-parent parent) install-dir))
                              (if first?
                                  (set! first? #f)
                                (increase-pos task)))))
              force-feedback?: #t))
          (increase-pos task)
          (set-done task)
          (post-event cont))
        'current))))


(define (install-root task cont)
  (define ignored-packages
    '("jazz.action"
      "jazz.application"
      "jazz.cairo"
      "jazz.clipboard"
      "jazz.component"
      "jazz.core"
      "jazz.crash"
      "jazz.debuggee"
      "jazz.debuggee.jazz"
      "jazz.debuggee.stub"
      "jazz.debugger"
      "jazz.debugger.jazz"
      "jazz.document"
      "jazz.event"
      "jazz.exemplar"
      "jazz.feedback"
      "jazz.figure"
      "jazz.fontconfig"
      "jazz.fonts"
      "jazz.freetype"
      "jazz.git"
      "jazz.graphic"
      "jazz.handler"
      "jazz.history"
      "jazz.inspector"
      "jazz.layout"
      "jazz.locale"
      "jazz.locator"
      "jazz.markup"
      "jazz.math"
      "jazz.media"
      "jazz.menu"
      "jazz.network"
      "jazz.outline"
      "jazz.preferences"
      "jazz.presence"
      "jazz.print"
      "jazz.process"
      "jazz.product"
      "jazz.profile"
      "jazz.reference"
      "jazz.resource"
      "jazz.resources"
      "jazz.runtime"
      "jazz.screen"
      "jazz.selection"
      "jazz.settings"
      "jazz.skin"
      "jazz.snapshot"
      "jazz.template"
      "jazz.text"
      "jazz.tree"
      "jazz.undoer"
      "jazz.ui"
      "jazz.view"
      "jazz.window"
      "jazz.workspace"
      "jazz.zlib"))
  
  (let ((from-exe (make-file (launch-exe)))
        (from-lib (make-directory (launch-lib)))
        (to-exe (make-file (root-exe)))
        (to-lib (make-directory (root-lib))))
    (set-range task (new Range 0 (+ 1 (count-zero-deep from-lib ignore: ignored-packages))))
    (thread-start!
      (new-thread
        (lambda ()
          (install-file from-exe to-exe)
          (cond-expand
            (windows
              (let ()
                (define (install-dll filename)
                  (install-file (make-file (launch-file filename)) (make-file (root-file filename))))
                
                (install-dll "libgcc_s_dw2-1.dll")
                (install-dll "libstdc++-6.dll"))))
          (increase-pos task)
          (let ((first? #t))
            (install-directory from-lib to-lib
              filter: (lambda (action pathname)
                        (if (and (eq? action 'copy)
                                 (pathname=? (get-parent pathname) from-lib)
                                 (let ((filename (get-name pathname)))
                                   (member? filename ignored-packages
                                     test: filename=?)))
                            #f
                          #t))
              feedback: (lambda (action pathname)
                          (when (pathname=? (get-parent pathname) from-lib)
                            (if first?
                                (set! first? #f)
                              (increase-pos task))))
              force-feedback?: #t))
          (for-each (lambda (ignored)
                      (let ((dir (new-directory to-lib ignored)))
                        (when (exists? dir)
                          (delete dir)
                          (increase-pos task))))
                    ignored-packages)
          (increase-pos task)
          (set-done task)
          (post-event cont))
        'root))))


(cond-expand
  (windows
   (define (install-platform)
     (install-desktop)
     (install-start-menu))
   
   (define (install-desktop)
     (let ((path (root-exe))
           (shortcut (desktop-shortcut)))
       (let ((hr (create-shortcut path #f shortcut (jiri-title))))
         (when (< hr 0)
           (continuable-error (format "Unable to create desktop shortcut ({x})" hr))))))
   
   (define (install-start-menu)
     @convert
     (let ((root (root-exe))
           (appdir (start-menu-appdir)))
       (when (file-exists? appdir)
         ;; danger
         (remove-directory appdir))
       (create-directory appdir)
       (let ((shortcut (start-menu-shortcut appdir)))
         (let ((hr (create-shortcut root #f shortcut (jiri-title))))
           (when (< hr 0)
             (continuable-error (format "Unable to create start menu shortcut ({x})" hr))))))))
  (else
   (define (install-platform)
     )))


(cond-expand
  (windows
   (define (update-start-menu)
     @convert
     (let ((root (root-exe))
           (appdir (start-menu-appdir)))
       (when (file-exists? appdir)
         (let ((title "Video Card Information"))
           (let ((shortcut (string-append appdir "/" title ".lnk")))
             (let ((hr (create-shortcut root "-information" shortcut title)))
               (when (< hr 0)
                 (continuable-error (format "Unable to create start menu shortcut ({x})" hr))))))))))
  (else
   (define (update-start-menu)
     )))


;; hack around windows taking forever to remove newly installed highlight
(define (rewind-start-menu)
  @convert
  (let ((shortcut (start-menu-shortcut (start-menu-appdir))))
    (when (file-exists? shortcut)
      (rewind-creation-time shortcut))))


(define (install-uninstall)
  @convert
  (let ((key (registry-create-key (HKEY_CURRENT_USER) (uninstall-subkey))))
    (registry-set-string key "DisplayName" (jiri-title))
    (registry-set-string key "DisplayIcon" (pathname-platformize (root-exe)))
    (registry-set-string key "DisplayVersion" (jiri-version))
    (registry-set-string key "Publisher" (jiri-company))
    (registry-set-string key "InstallDate" (get-local-date))
    (registry-set-string key "InstallLocation" (pathname-platformize (current-root-dir)))
    (registry-set-string key "UninstallString" (string-append (pathname-platformize (root-exe)) " -uninstall"))
    (registry-set-int key "EstimatedSize" (jiri-size))
    (registry-set-int key "NoModify" 1)
    (registry-set-int key "NoRepair" 1)
    (registry-close-key key)))


;;;
;;;; Layout
;;;


(define (jiri-layout)
  (add-view root-view)
  (add-view invite-view)
  (when close-view
    (add-view close-view))
  (when minimize-view
    (add-view minimize-view))
  (add-view connections-view)
  (let ((section (jiri-app-section)))
    (let ((connections (get-connections section))
          (default (get-default section)))
      (if (not connections)
          (let ((connection (get-connection section))
                (tree (locate connections-view 'tree)))
            (add-row tree children: (list (new Tree-Node title: (get-title connection))) user-data: connection)
            (set-single-selection tree 0))
        (assert default)
        (set-connection-change
          (lambda (connection)
            (set-connection (jiri-app-section) connection)))
        (let ((tree (locate connections-view 'tree)))
          (for-each (lambda (connection)
                      (add-row tree children: (list (new Tree-Node title: (get-title connection))) user-data: connection))
                    connections)
          (let ((default-connection (find connections default key: get-title~ test: equal? return: 'item)))
            (select-user-data-row tree default-connection)))
        (set-connection-change
          (lambda (connection)
            (set-connection (jiri-app-section) connection)
            (unless (get-started? connection)
              (pull-repository (jiri-app-section) (current-password) (app-dir)
                (lambda (new-content?)
                  ))))))))
  (if (eq? stage 'install-from-setup)
      (add-stage-view "Setup successful!" stage-install-color)
    (add-stage-view (string-append "Updating " (game-string)) stage-install-color))
  (add-view percentage-view)
  (add-view downloaded-view)
  (add-view status-view)
  (add-view remaining-view)
  (add-view progress-view)
  (add-view play-view)
  (when (neq? stage 'install-from-root)
    ;;convert-to-task(set-title downloaded-view (string-append "Downloaded: " (number->string work-downloaded) "M"))
    ;;convert-to-task(set-title status-view (downloading-title (get-title (jiri-app-section)) 3 6))
    ;;convert-to-task(set-info progress-view (new Range (first (get-limits (jiri-app-section))) (third (get-limits (jiri-app-section)))) (new Range 0 10))
    )
  (set-return-callback
    (lambda ()
      (when work-done?
        (play))))
  (set-quit-callback
    (let ((quit-safely (quit-safely)))
      (lambda ()
        (mutex-lock! sending-crash-reports-mutex)
        (quit-safely)))))


;;;
;;;; Init
;;;


(set-jiri-init
  (lambda ()
    (jiri-prepare)
    (jiri-layout)))


;;;
;;;; Startup
;;;


(set-jiri-startup
  (lambda ()
    (jiri-install)))))
