;;;==============
;;;  JiriScheme
;;;==============
;;;
;;;; Install
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  See www.jazzscheme.org for details.


(module jiri.install jazz


(import (jazz.event)
        (jazz.git.foreign)
        (jazz.io)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (jiri.base)
        (jiri.git-interface)
        (jiri.platform)
        (jiri.view)
        (jiri.settings)
        (jiri.structure)
        (jiri.task)
        (jiri.window)
        (jiri.work))


(define TEST?
  #f)

(define TEST-INSTALL?
  #f)


(define stage
  #f)


(define (prepare)
  (when (and TEST? kernel-source-accessible? (not (getenv-default "called-from")))
    (setenv "root-dir" "C:/Program Files (x86)/Sirius Test/")
    (setenv "called-from" "root"))
  
  (current-root-dir (getenv-default "root-dir"))
  (current-password (getenv-default "password"))
  (called-from (getenv-default "called-from"))
  (set! stage (cond ((and (current-root-dir)
                          (equal? (called-from) "setup"))
                     'install-from-setup)
                    ((and (current-root-dir)
                          (equal? (called-from) "root"))
                     'install-from-root)
                    ((and (current-root-dir)
                          (equal? (called-from) "current"))
                     'install-from-current)
                    (else
                     (message-box "It is incorrect to launch this application")
                     (exit 1))))
  (when (neq? stage 'install-from-root)
    (set-work-downloaded (string->number (getenv-default "work-downloaded" "0")))
    (set-window-h (string->number (getenv-default "window-h" "-1")))
    (set-window-v (string->number (getenv-default "window-v" "-1")))
    (set-send-ready? (getenv-default "send-ready" #f))))


;;;
;;;; Install
;;;


(define (install)
  (case stage
    ((install-from-setup) (install-from-setup))
    ((install-from-root) (install-from-root))
    ((install-from-current) (install-from-current))))


(define (install-tasks-done)
  (for-each set-done~ (get-children~ (get-connection~ (jiri-install-section)))))


(define (transfer-tasks-setup proc)
  (let ((section (jiri-transfer-section))
        (app-section (jiri-app-section)))
    (set-part~ section .1)
    (set-part~ app-section (- (get-part~ app-section) .1))
    (proc (add-task~ section (new Jiri-Task part: .8))
          (add-task~ section (new Jiri-Task part: .2)))))


(define (work-offline)
  (bell)
  (set-cursor :arrow)
  (set-title~ stage-view "Unable to connect to server")
  (if (file-exists? (app-exe))
      (begin
        (set-work-done? #t)
        (set-color~ stage-view stage-install-color)
        (set-enabled?~ play-view #t))
    (set-color~ stage-view stage-setup-color)
    (set-title~ play-view "Not found")
    (set-enabled?~ play-view #f)))


;;;
;;;; Install From Setup
;;;


(define (install-from-setup)
  (catch (Git-Exception exc
           (if (jiri-offline?)
               (work-offline)
             (exit 1)))
    (set-cursor :wait)
    (install-tasks-done)
    (transfer-tasks-setup
      (lambda (current-task root-task)
        (install-current current-task
          (lambda ()
            (install-root root-task
              (lambda ()
                (install-platform)
                (update-start-menu)
                (install-uninstall)
                (install-application/world
                  (lambda (new-content?)
                    (install-done)))))))))))


;;;
;;;; Install From Root
;;;


(define (install-from-root)
  (catch (Git-Exception exc
           (if (jiri-offline?)
               (work-offline)
             (exit 1)))
    (pull-repository (jiri-install-section) (current-password) (install-dir)
      (lambda (new-content?)
        (if new-content?
            (delegate-install (current-root-dir) (current-password) "current")
          (begin
            (start-send-crash-reports)
            (update-start-menu)
            (rewind-start-menu)
            (install-application/world
              (lambda (new-content?)
                (install-done))))))
      #t)))


;;;
;;;; Install From Current
;;;


(define (install-from-current)
  (catch (Git-Exception exc
           (if (jiri-offline?)
               (work-offline)
             (exit 1)))
    (set-cursor :wait)
    (start-send-crash-reports)
    (install-tasks-done)
    (transfer-tasks-setup
      (lambda (current-task root-task)
        (install-current current-task
          (lambda ()
            (install-root root-task
              (lambda ()
                (update-start-menu)
                (rewind-start-menu)
                (install-application/world
                  (lambda (new-content?)
                    (install-done)))))))))))


;;;
;;;; Crashes
;;;


(define sending-crash-reports-mutex
  (make-mutex 'sending-crash-reports))


(define (start-send-crash-reports)
  (thread-start!
    (new-thread
      (lambda ()
        (mutex-lock! sending-crash-reports-mutex)
        (send-crash-reports)
        (mutex-unlock! sending-crash-reports-mutex))
      'send-crash-reports)))


(define (send-crash-reports)
  (let ((monitor (jiri-monitor-crashes)))
    (when monitor
      (let ((curl (curl-path)))
        (when (file-exists? curl)
          (continuation-capture
            (lambda (stop)
              (define (send-all name crashes-dir remote)
                (let ((draft-dir (new-directory~ crashes-dir "draft"))
                      (sent-dir (new-directory~ crashes-dir "sent")))
                  (define (send-report file draft?)
                    (when (extension=? (get-extension~ file) "snapshot")
                      (let ((port (open-process
                                      (list
                                        path: curl
                                        arguments: (list "--silent" "-X" "PUT" "-T" (parse~ file) "-H" "Content-Type: text/plain" (string-append remote "/crashes/" (get-name~ file)))
                                        show-console: #f))))
                        @debug
                        (let ((line (read-line port #f)))
                          (call-with-output-file (path-settings {File Home "sirius.log"} append: #t)
                            (lambda (port)
                              (write line port)
                              (newline port)
                              (write file port)
                              (newline port)
                              (write curl port)
                              (newline port)
                              (write (list "--silent" "-X" "PUT" "-T" (parse~ file) "-H" "Content-Type: text/plain" (string-append remote "/crashes/" (get-name~ file))) port)
                              (newline port))))
                        (let ((status (process-status port)))
                          (cond ((= status 0)
                                 (create-directories~ sent-dir)
                                 (move-pathname~ file (new-file~ sent-dir (get-name~ file))))
                                (else
                                 (unless draft?
                                   (create-directories~ draft-dir)
                                   (move-pathname~ file (new-file~ draft-dir (get-name~ file))))
                                 (continuation-return stop #f)))))))
                  
                  (define (send-reports dir draft?)
                    (when (exists?~ dir)
                      (for-each (lambda (file)
                                  (send-report file draft?))
                                (collect-files~ dir
                                  (lambda (file)
                                    #t)))))
                  
                  (define (send-crashes)
                    (send-reports crashes-dir #f))
                  
                  (define (send-drafts)
                    (send-reports draft-dir #t))
                  
                  (send-crashes)
                  (send-drafts)))
              
              (for-each (lambda (info)
                          (bind (name dir remote) info
                            (send-all name dir remote)))
                        monitor))))))))


;;;
;;;; Curl
;;;


(cond-expand
  (windows
   (definition public (curl-path)
     (parse~ {File Build "curl.exe"})))
  (else
   (definition public (curl-path)
     "/usr/bin/curl")))


;;;
;;;; Work
;;;


(define (install-application/world cont)
  (pull-repository (jiri-app-section) (current-password) (app-dir)
    (lambda (new-content?)
      (cond ((world-dir)
             (pull-repository (jiri-world-section) (current-password) (world-dir)
               cont
               #t))
            ((jiri-world-work)
             ((jiri-world-work) (jiri-world-section) 5 6 cont))))
    #t))


;;;
;;;; Done
;;;


(define (install-done)
  (set-title~ stage-view (or (jiri-play-ready) "Ready to play!"))
  (set-color~ stage-view stage-ready-color)
  (set-title~ status-view "Done")
  (set-cursor :arrow)
  (set-work-done? #t))


(define (count-zero-deep dir (ignore: ignore #f))
  (let ((count 0))
    (iterate-directory~ dir
      (lambda (path)
        (let ((filename (get-name~ path)))
          (unless (or (filename=? filename ".git")
                      (and ignore
                           (member? filename ignore
                             test: filename=?)))
            (increase! count))))
      files?: #t
      directories?: #t
      recursive?: #f)
    count))


(define (count-one-deep dir)
  (let ((count 0))
    (iterate-directory~ dir
      (lambda (path)
        (increase! count)
        (when (and (directory? path)
                   (not (filename=? (get-name~ path) ".git")))
          (iterate-directory~ path
            (lambda (path)
              (increase! count))
            files?: #t
            directories?: #t
            recursive?: #f)))
      files?: #t
      directories?: #t
      recursive?: #f
      ignored-toplevel-dirnames: '(".git"))
    count))


(define (install-current task cont)
  (let ((install-dir (make-directory (install-dir)))
        (current-dir (make-directory (current-dir))))
    (set-range~ task (new Range 0 (count-one-deep install-dir)))
    (thread-start!
      (new-thread
        (lambda ()
          (let ((first? #t))
            (install-directory~ install-dir current-dir
              filter: (lambda (action pathname)
                        (if (and (eq? action 'copy)
                                 (pathname=? (get-parent~ pathname) install-dir)
                                 (filename=? (get-name~ pathname) ".git"))
                            #f
                          #t))
              feedback: (lambda (action pathname)
                          (let ((parent (get-parent~ pathname)))
                            (when (or (pathname=? parent install-dir)
                                      (pathname=? (get-parent~ parent) install-dir))
                              (if first?
                                  (set! first? #f)
                                (increase-pos~ task)))))
              force-feedback?: #t))
          (increase-pos~ task)
          (set-done~ task)
          (post-event cont))
        'current))))


(define (install-root task cont)
  (define ignored-packages
    '("jazz.action"
      "jazz.application"
      "jazz.cairo"
      "jazz.clipboard"
      "jazz.component"
      "jazz.core"
      "jazz.crash"
      "jazz.debuggee"
      "jazz.debuggee.jazz"
      "jazz.debuggee.stub"
      "jazz.debugger"
      "jazz.debugger.jazz"
      "jazz.document"
      "jazz.event"
      "jazz.exemplar"
      "jazz.feedback"
      "jazz.figure"
      "jazz.fontconfig"
      "jazz.fonts"
      "jazz.freetype"
      "jazz.git"
      "jazz.graphic"
      "jazz.handler"
      "jazz.history"
      "jazz.inspector"
      "jazz.jml"
      "jazz.jrm"
      "jazz.layout"
      "jazz.locale"
      "jazz.locator"
      "jazz.math"
      "jazz.media"
      "jazz.menu"
      "jazz.network"
      "jazz.outline"
      "jazz.preferences"
      "jazz.print"
      "jazz.process"
      "jazz.product"
      "jazz.profile"
      "jazz.reference"
      "jazz.resource"
      "jazz.resources"
      "jazz.runtime"
      "jazz.screen"
      "jazz.selection"
      "jazz.settings"
      "jazz.skin"
      "jazz.snapshot"
      "jazz.template"
      "jazz.text"
      "jazz.tree"
      "jazz.undoer"
      "jazz.ui"
      "jazz.view"
      "jazz.window"
      "jazz.workspace"
      "jazz.zlib"))
  
  (let ((from-exe (make-file (launch-exe)))
        (from-lib (make-directory (launch-lib)))
        (to-exe (make-file (root-exe)))
        (to-lib (make-directory (root-lib))))
    (set-range~ task (new Range 0 (+ 1 (count-zero-deep from-lib ignore: ignored-packages))))
    (thread-start!
      (new-thread
        (lambda ()
          (install-file~ from-exe to-exe)
          (increase-pos~ task)
          (let ((first? #t))
            (install-directory~ from-lib to-lib
              filter: (lambda (action pathname)
                        (if (and (eq? action 'copy)
                                 (pathname=? (get-parent~ pathname) from-lib)
                                 (let ((filename (get-name~ pathname)))
                                   (member? filename ignored-packages
                                     test: filename=?)))
                            #f
                          #t))
              feedback: (lambda (action pathname)
                          (when (pathname=? (get-parent~ pathname) from-lib)
                            (if first?
                                (set! first? #f)
                              (increase-pos~ task))))
              force-feedback?: #t))
          (for-each (lambda (ignored)
                      (let ((dir (new-directory~ to-lib ignored)))
                        (when (exists?~ dir)
                          (delete-directory~ dir)
                          (increase-pos~ task))))
                    ignored-packages)
          (increase-pos~ task)
          (set-done~ task)
          (post-event cont))
        'root))))


(cond-expand
  (windows
   (define (install-platform)
     (install-desktop)
     (install-start-menu))
   
   (define (install-desktop)
     (let ((path (root-exe))
           (shortcut (desktop-shortcut)))
       (let ((hr (create-shortcut path #f shortcut (jiri-title))))
         (when (< hr 0)
           (continuable-error (format "Unable to create desktop shortcut ({x})" hr))))))
   
   (define (install-start-menu)
     @convert
     (let ((root (root-exe))
           (appdir (start-menu-appdir)))
       (when (file-exists? appdir)
         ;; danger
         (remove-directory appdir))
       (create-directory appdir)
       (let ((shortcut (start-menu-shortcut appdir)))
         (let ((hr (create-shortcut root #f shortcut (jiri-title))))
           (when (< hr 0)
             (continuable-error (format "Unable to create start menu shortcut ({x})" hr))))))))
  (else
   (define (install-platform)
     )))


(cond-expand
  (windows
   (define (update-start-menu)
     @convert
     (let ((root (root-exe))
           (appdir (start-menu-appdir)))
       (when (file-exists? appdir)
         (let ((title "Video Card Information"))
           (let ((shortcut (string-append appdir "/" title ".lnk")))
             (let ((hr (create-shortcut root "-information" shortcut title)))
               (when (< hr 0)
                 (continuable-error (format "Unable to create start menu shortcut ({x})" hr))))))))))
  (else
   (define (update-start-menu)
     )))


;; hack around windows taking forever to remove newly installed highlight
(define (rewind-start-menu)
  @convert
  (let ((shortcut (start-menu-shortcut (start-menu-appdir))))
    (when (file-exists? shortcut)
      (rewind-creation-time shortcut))))


(define (install-uninstall)
  @convert
  (let ((key (registry-create-key (HKEY_CURRENT_USER) (uninstall-subkey))))
    (registry-set-string key "DisplayName" (jiri-title))
    (registry-set-string key "DisplayIcon" (pathname-platformize (root-exe)))
    (registry-set-string key "DisplayVersion" (jiri-version))
    (registry-set-string key "Publisher" (jiri-company))
    (registry-set-string key "InstallDate" (get-local-date))
    (registry-set-string key "InstallLocation" (pathname-platformize (current-root-dir)))
    (registry-set-string key "UninstallString" (string-append (pathname-platformize (root-exe)) " -uninstall"))
    (registry-set-int key "EstimatedSize" (jiri-size))
    (registry-set-int key "NoModify" 1)
    (registry-set-int key "NoRepair" 1)
    (registry-close-key key)))


;;;
;;;; Layout
;;;


(define (layout)
  (add-view root-view)
  (add-view invite-view)
  (when close-view
    (add-view close-view))
  (when minimize-view
    (add-view minimize-view))
  (add-view connections-view)
  (let ((section (jiri-app-section)))
    (let ((connections (get-connections~ section))
          (default (get-default~ section)))
      (if (not connections)
          (let ((connection (get-connection~ section))
                (tree (locate~ connections-view 'tree)))
            (add-row~ tree children: (list (new Tree-Node title: (get-title~ connection))) user-data: connection)
            (set-single-selection~ tree 0))
        (assert default)
        (set-connection-change
          (lambda (connection)
            (set-connection~ (jiri-app-section) connection)))
        (let ((tree (locate~ connections-view 'tree)))
          (for-each (lambda (connection)
                      (add-row~ tree children: (list (new Tree-Node title: (get-title~ connection))) user-data: connection))
                    connections)
          (let ((default-connection (find connections default key: get-title~ test: equal? return: 'item)))
            (select-user-data-row~ tree default-connection)))
        (set-connection-change
          (lambda (connection)
            (set-connection~ (jiri-app-section) connection)
            (unless (get-started?~ connection)
              (pull-repository (jiri-app-section) (current-password) (app-dir)
                (lambda (new-content?)
                  ))))))))
  (if (eq? stage 'install-from-setup)
      (add-stage-view "Setup successful!" stage-install-color)
    (add-stage-view (string-append "Updating " (game-string)) stage-install-color))
  (add-view percentage-view)
  (add-view downloaded-view)
  (add-view status-view)
  (add-view remaining-view)
  (add-view progress-view)
  (add-view play-view)
  (when (neq? stage 'install-from-root)
    ;;convert-to-task(set-title~ downloaded-view (string-append "Downloaded: " (number->string work-downloaded) "M"))
    ;;convert-to-task(set-title~ status-view (downloading-title (get-title~ (jiri-app-section)) 3 6))
    ;;convert-to-task(set-info~ progress-view (new Range (first (get-limits~ (jiri-app-section))) (third (get-limits~ (jiri-app-section)))) (new Range 0 10))
    )
  (set-return-callback
    (lambda ()
      (when work-done?
        (play))))
  (set-quit-callback
    (let ((quit-safely (quit-safely)))
      (lambda ()
        (mutex-lock! sending-crash-reports-mutex)
        (quit-safely)))))


;;;
;;;; Init
;;;


(set-init
  (lambda ()
    (prepare)
    (layout)))


;;;
;;;; Startup
;;;


(set-startup
  (lambda ()
    (when (or TEST-INSTALL? (not kernel-source-accessible?))
      (install)))))
