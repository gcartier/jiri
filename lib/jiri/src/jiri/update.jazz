;;;==============
;;;  JiriScheme
;;;==============
;;;
;;;; Update
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  See www.jazzscheme.org for details.


(module jiri.update jazz


(import (jazz.application)
        (jazz.component)
        (jazz.event)
        (jazz.git.foreign)
        (jazz.io)
        (jazz.outline)
        (jazz.platform)
        (jazz.settings)
        (jazz.snapshot)
        (jazz.tree)
        (jazz.view)
        (jazz.window)
        (jiri)
        (jiri.base)
        (jiri.git)
        (jiri.manage)
        (jiri.monitor)
        (jiri.settings)
        (jiri.structure)
        (jiri.task)
        (jiri.view)
        (jiri.window)
        (jiri.work))


;; MAC
;; Contents
;; - App
;;   - update.app
;;     - Contents
;;       - Libraries
;;       - MacOS
;;         - .git
;;         - Yownu (update)
;;       - Resources
;;   - yownu.app
;;     - Contents
;;       - Libraries
;;       - MacOS
;;         - .git
;;         - Yownu (app)
;;       - Resources
;; - Libraries
;; - MacOS
;;   - Yownu (launch)
;; - Resources
;; - Worlds
;;   - yownu
;;     - .git

;; WINDOWS
;; Yownu (launch)
;; lib
;; sirius
;; - current
;; - sirius-install
;;   - .git
;; worlds
;; - together
;;   - .git
;; yownu (why not app)
;; - test
;;   - Yownu (app)
;;     - .git


(define stage
  #f)


(define (jiri-prepare)
  (define (inside-installer?)
    (cond-expand
      (mac
       (and kernel-bundle-root
            (let ((root (new Directory (tokenise-filename kernel-bundle-root))))
              (and (filename=? (get-name root) "Update.app")
                   (let ((apps (get-parent root)))
                     (and (filename=? (get-name apps) "Apps")
                          (let ((contents (get-parent apps)))
                            (and (filename=? (get-name contents) "Contents")
                                 (exists? (new-directory contents "Libraries"))
                                 (exists? (new-directory contents "MacOS"))))))))))
      (else
       #f)))
  
  (current-root-dir (string-argument "root-dir" #f))
  (called-from (string-argument "called-from" #f))
  (set! stage (cond ((and (not (current-root-dir))
                          (not (called-from))
                          (not (inside-installer?)))
                     'launch)
                    ((and (current-root-dir)
                          (equal? (called-from) "launch"))
                     'update)
                    (else
                     (system-message "It is incorrect to launch this application"
                                     type: 'problem
                                     title: "Update")
                     (exit 1))))
  (when (eq? stage 'update)
    (set-work-downloaded (integer-argument "work-downloaded" 0))
    (set-window-h (integer-argument "window-h" -1))
    (set-window-v (integer-argument "window-v" -1))
    (set-send-ready? (boolean-argument "send-ready" #f))))


(define (was-update-new?)
  (equal? (string-argument "update-new" "yes") "yes"))


;;;
;;;; Update
;;;


(define (update)
  (case stage
    ((launch) (update-at-launch))
    ((update) (update-at-update))))


(define (update-tasks-done)
  (for-each set-done (get-children (get-connection (jiri-update-section)))))


(define (transfer-tasks-setup proc)
  (let ((section (jiri-transfer-section)))
    (bind (transfer-task) (get-tasks section)
      (proc transfer-task))))


(define (update-exception-message exc)
  (define (debug-info)
    (string-append " (" (get-message exc) ")"))
  
  (if (or (not (file-exists? (app-dir)))
          (not (file-exists? (data-dir))))
      (string-append "Failed to install " (game-string) (debug-info))
    (string-append "Failed to update " (game-string) (debug-info))))


(define (catch-git-exception thunk)
  (catch (Git-Exception exc
           (let ((exception-message (update-exception-message exc)))
             (delay-event
               (lambda ()
                 (system-message exception-message
                                 type: 'problem
                                 title: (jiri-application))
                 (snapshot-process exception: exc)
                 (exit 1)))))
    (thunk)))


(define first-install?
  #f)

(define (setup-first-install?)
  (set! first-install? (or (not (file-exists? (update-dir)))
                           (not (file-exists? (app-dir)))
                           (not (file-exists? (data-dir))))))


(define (setup-stage-view title color)
  (if first-install?
      (add-stage-view (string-append "Installing " (jiri-title) " for the first time, please be patient") stage-install-color)
    (add-stage-view title stage-ready-color)))


;;;
;;;; At Launch
;;;


(define (update-at-launch)
  (current-root-dir (cond-expand
                      (mac kernel-bundle-root)
                      (else jazz:kernel-install)))
  (setup-first-install?)
  (let ((update-new? (not (file-exists? (update-dir)))))
    (setup-stage-view (string-append "Updating " (jiri-title)) (determine-stage-color (update-dir)))
    (update-crashes-view-color)
    (thread-start!
      (new-thread
        (lambda ()
          (send-crash-reports (jiri-installer-crashes) #f)
          (catch-git-exception
            (lambda ()
              (pull-repository (jiri-update-section) (update-dir)
                (lambda (new-content?)
                  (if (cond-expand
                        (local #f)
                        (else new-content?))
                      (delegate-update (current-root-dir) "launch" update-new?)
                    (transfer-tasks-setup
                      (lambda (transfer-task)
                        (set-done transfer-task)
                        (update-app/data
                          (lambda (new-content?)
                            (set! first-install? #f)
                            (if (not (jiri-splash-section))
                                (update-done)
                              (launch-app new-content?
                                (lambda ()
                                  (update-done))))))))))))))
        'launch))))


(definition public (delegate-update root-dir called-from update-new?)
  (let ((arguments
          (build-arguments
            (lambda (add)
              (add "root-dir" root-dir)
              (add "called-from" called-from)
              (add "update-new" (if update-new? "yes" "no"))
              (add "work-downloaded" (number->string (or (calculate-downloaded) 0)))
              (let ((pos (get-position (current-toplevel))))
                (add "window-h" (number->string (get-h pos)))
                (add "window-v" (number->string (get-v pos))))
              (add "send-ready" "true")))))
    (delegate-process (update-exe) arguments: arguments wait-and-quit?: #t)))


;;;
;;;; At Update
;;;


(define (update-at-update)
  (setup-first-install?)
  (setup-stage-view (string-append "Updating " (jiri-title)) (if (was-update-new?) stage-setup-color stage-install-color))
  (update-crashes-view-color)
  (update-tasks-done)
  (transfer-tasks-setup
    (lambda (transfer-task)
      (thread-start!
        (new-thread
          (lambda ()
            (update-launch transfer-task
              (lambda ()
                (catch-git-exception
                  (lambda ()
                    (update-app/data
                      (lambda (new-content?)
                        (set! first-install? #f)
                        (if (not (jiri-splash-section))
                            (update-done)
                          (launch-app new-content?
                            (lambda ()
                              (update-done)))))))))))
          'update)))))


(define (update-launch task cont)
  (let ((update-dir (dirname->directory (update-dir)))
        (root-dir (dirname->directory (current-root-dir))))
    (define (install-filename filename)
      (install-file
        (new-file update-dir filename)
        (new-file root-dir filename)))
    
    (define (install-dirname dirname)
      (install-directory
        (new-directory update-dir dirname)
        (new-directory root-dir dirname)))
    
    (define (install-libraries dirname libdir)
      (let ((src-dir (new-directory update-dir dirname))
            (dst-dir (new-directory root-dir dirname)))
        (install-directory
          src-dir
          dst-dir
          filter: (cond-expand
                    (mac
                      #f)
                    (else
                      ;; quick hack that needs to be thought through
                      (lambda (action pathname)
                        (if (and (memq? action '(replace delete))
                                 (directory? pathname)
                                 (member? (get-name pathname) '(".git" "app" "worlds") test: filename=?)
                                 (let ((parent-dir (get-parent pathname)))
                                   (or (pathname=? parent-dir src-dir)
                                       (pathname=? parent-dir dst-dir))))
                            #f
                          #t))))
          progress-feedback: (lambda (action dir)
                               (when (and (eq? action 'entering)
                                          (pathname=? (get-parent dir) libdir))
                                 (increase-pos task))))))
    
    (set-status task "Updating sirius")
    (cond-expand
      (mac
       (let ((libdir (new-directory update-dir "Contents/Libraries/lib")))
         (let ((package-count (count-directories libdir)))
           (set-range task (new Range 0 package-count))
           (install-filename "Contents/Info.plist")
           (install-dirname "Contents/MacOS")
           (install-dirname "Contents/Resources")
           (install-libraries "Contents/Libraries" libdir)
           (set-done task)
           (cont))))
      (else
       (let ((libdir (new-directory update-dir "lib")))
         (let ((package-count (count-directories libdir)))
           (set-range task (new Range 0 package-count))
           (install-libraries '() libdir)
           (set-done task)
           (cont)))))))


;;;
;;;; Work
;;;


(define (determine-stage-color dir)
  (if (not (file-exists? dir))
      stage-setup-color
    stage-install-color))


(define (update-app/data cont)
  (setup-stage-view (string-append "Updating " (game-string)) (determine-stage-color (app-dir)))
  (update-crashes-view-color)
  (pull-repository (jiri-app-section) (app-dir)
    (lambda (new-app-content?)
      (setup-stage-view (string-append "Updating " (get-title (jiri-data-section))) (determine-stage-color (data-dir)))
      (update-crashes-view-color)
      (pull-repository (jiri-data-section) (data-dir)
        (lambda (new-data-content?)
          (cont (or new-app-content? new-data-content?)))))))


(define (launch-app new-content? cont)
  (let ((section (jiri-splash-section)))
    (bind (task) (get-tasks section)
      (setup-stage-view (if new-content? (jiri-splash-updated) (jiri-splash-uptodate)) stage-ready-color)
      (set-status task "Launching application")
      (set-remaining task (jiri-splash-end))
      (set-range task (new Range 0 (jiri-splash-end)))
      (let ((server-port (open-tcp-server 0)))
        (let ((arguments
                (build-arguments
                  (lambda (add)
                    (add "load-feedback" (number->string (socket-info-port-number (tcp-server-socket-info server-port))))
                    (add "called-from" "installer")))))
          (delegate-process (app-exe) arguments: arguments))
        (thread-start!
          (new-thread
            (lambda ()
              (declare (proper-tail-calls))
              (with-exception-catcher
                (lambda (exc)
                  (launch-problem))
                (lambda ()
                  (let ((port (read server-port)))
                    (let (loop (n 0))
                      (let ((unit-name (read port)))
                        (cond ((eof-object? unit-name)
                               (launch-problem))
                              ((equal? unit-name '(done))
                               (cont))
                              (else
                               (increase-pos task)
                               (decrease-remaining-if task)
                               (loop (+ n 1))))))))))
            'splash))))))


(define (launch-problem)
  (set-title stage-view "Problem encountered launching application")
  (set-color stage-view stage-error-color)
  (set-cursor :arrow)
  (set-work-done? #t)
  (update-crashes-view-color)
  (send-crash-reports (jiri-application-crashes) #t))


;;;
;;;; Done
;;;


(define (update-done)
  (unless (jiri-splash-section)
    (set-title stage-view (or (jiri-play-ready) "Ready to play!"))
    (set-color stage-view stage-ready-color)
    (set-title status-view "Done"))
  (set-cursor :arrow)
  (set-work-done? #t)
  (update-crashes-view-color)
  (send-crash-reports (jiri-application-crashes) #t)
  (when (jiri-splash-section)
    (quit-callback)))


;;;
;;;; Layout
;;;


(define (jiri-layout)
  (add-pane-view root-view)
  (add-pane-view invite-view)
  (when close-view
    (add-pane-view close-view))
  (when minimize-view
    (add-pane-view minimize-view))
  
  (when (jiri-connections?)
    (add-pane-view connections-view))
  (let ((section (jiri-app-section)))
    (let ((connections (get-connections section))
          (default (get-default section)))
      (if (not connections)
          (let ((connection (get-connection section))
                (tree (locate connections-view 'tree)))
            (add-row tree children: (list (new Tree-Node title: (get-title connection))) user-data: connection)
            (set-single-selection tree 0))
        (assert default)
        (set-connection-change
          (lambda (connection)
            (set-connection (jiri-app-section) connection)))
        (let ((tree (locate connections-view 'tree)))
          (for-each (lambda (connection)
                      (add-row tree children: (list (new Tree-Node title: (get-title connection))) user-data: connection))
                    connections)
          (let ((default-connection (find connections default key: get-title test: equal? return: 'item)))
            (select-user-data-row tree default-connection)))
        (set-connection-change
          (lambda (connection)
            (set-connection (jiri-app-section) connection)
            (unless (get-started? connection)
              (pull-repository (jiri-app-section) (app-dir)
                (lambda (new-content?)
                  ))))))))
  
  (unless (jiri-splash-section)
    (add-stage-view (string-append "Updating " (game-string)) stage-install-color))
  (add-crashes-view "" stage-install-color)
  
  (when (jiri-splash-section)
    (set-position crashes-view (new Point 500 446))
    (set-position remaining-view (new Point 650 477))
    (set-size progress-view (new Dimension 750 20)))
  
  (add-pane-view percentage-view)
  (add-pane-view downloaded-view)
  (add-pane-view status-view)
  (add-pane-view remaining-view)
  (add-pane-view progress-view)
  (unless (jiri-splash-section)
    (add-pane-view play-view))
  ;; mimick launcher state
  (when (eq? stage 'update)
    ;;convert-to-task(set-title downloaded-view (string-append "Downloaded: " (number->string work-downloaded) "M"))
    ;;convert-to-task(set-title status-view (installing-title (jiri-update-title) 1 6))
    ;;convert-to-task(set-info progress-view (new Range 0. .1) (new Range 1 6))
    ;;convert-to-task(set-done progress-view)
    )
  (unless (jiri-splash-section)
    (set-return-callback
      (lambda ()
        (when work-done?
          (play-app)))))
  (set-quit-callback
    (quit-safely)))


;;;
;;;; Init
;;;


(set-jiri-init
  (lambda ()
    (jiri-prepare)
    (jiri-layout)))


;;;
;;;; Startup
;;;


(set-jiri-startup
  (lambda ()
    (update))))
