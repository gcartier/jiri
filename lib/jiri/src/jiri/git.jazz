;;;==============
;;;  JiriScheme
;;;==============
;;;
;;;; Git Interface
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  See www.jazzscheme.org for details.


(module jiri.git jazz


(import (jazz.application)
        (jazz.component)
        (jazz.event)
        (jazz.git.foreign)
        (jazz.git.interface)
        (jazz.graphic)
        (jazz.handler)
        (jazz.listener)
        (jazz.markup)
        (jazz.platform)
        (jazz.text)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.view)
        (jazz.window)
        (jiri)
        (jiri.base)
        (jiri.manage)
        (jiri.settings)
        (jiri.structure)
        (jiri.window)
        (jiri.work))


;;;
;;;; Pull
;;;


(definition public (pull-repository section password dir cont (remote-exception? #f))
  (let ((title (get-title section))
        (connection (get-connection section)))
    (let ((id (get-id connection))
          (name (get-name connection))
          (url (get-url connection))
          (branch (get-branch connection))
          (download-task (get-download-task connection))
          (checkout-task (get-checkout-task connection))
          (listener (open-stream-listener)))
      (define (open/init-repository proc)
        (let ((existing? (file-exists? dir)))
          (cond (existing?
                  (let ((repo (git-repository-open dir)))
                    (proc repo (git-remote-lookup repo "origin"))))
                (else
                 (let ((repo (git-repository-init dir)))
                   (proc repo (git-remote-create repo "origin" url)))))))
      
      (define (process-listener name listener progress done)
        (thread-start!
          (new-thread
            (lambda ()
              (declare (proper-tail-calls))
              (let (loop)
                (let ((c (wait listener)))
                  (case c
                    ((#\.)
                     (delay-event
                       (lambda ()
                         (progress #f)))
                     (loop))
                    ((#\@)
                     (close-stream-listener listener)
                     (delay-event
                       (lambda ()
                         (done #f))))
                    ((#\!)
                     (close-stream-listener listener)
                     (delay-event
                       (lambda ()
                         (done #t))))))))
            name)))
      
      (set-cursor :wait)
      (set-started? connection #t)
      (set-working? connection #t)
      (set-status download-task (string-append "Downloading " title))
      (open/init-repository
        (lambda (repo remote)
          (git-remote-connect-with-retries connection remote listener remote-exception?)
          (set-range download-task (new Range 0 1))
          (set-download-progress connection
            (let ((inited? #f))
              (lambda (error?)
                (git-download-state id
                  (lambda (total-objects received-objects received-bytes)
                    (let ((downloaded (fxfloor (/ (exact->inexact received-bytes) (* 1024. 1024.))))
                          (remaining (- total-objects received-objects)))
                      (set-downloaded download-task downloaded)
                      (set-remaining download-task remaining))
                    (when (not inited?)
                      (set-range download-task (new Range 0 total-objects))
                      (set! inited? #t))
                    (set-pos download-task received-objects))))))
          (set-download-done connection
            (lambda (error?)
              (unless (safe-abort-point
                        (lambda ()
                          (git-remote-disconnect remote)
                          (git-remote-free remote)
                          (git-repository-free repo)
                          (set-cursor :arrow)
                          (set-working? connection #f)))
                (when error?
                  (git-error))
                (set-status checkout-task (string-append "Installing " title))
                (set-done download-task)
                (git-remote-disconnect remote)
                (git-remote-update-tips remote)
                (git-remote-free remote)
                (git-repository-set-head repo (string-append "refs/heads/" branch))
                (let ((upstream (git-reference-lookup repo (string-append "refs/remotes/origin/" branch))))
                  (let ((commit (git-object-lookup repo (git-reference->id repo upstream) GIT_OBJ_COMMIT)))
                    (define (checkout-cleanup)
                      (git-reference-free upstream)
                      (git-object-free commit)
                      (git-repository-free repo)
                      (set-cursor :arrow)
                      (set-working? connection #f))
                    
                    (unless (git-branch-lookup repo branch GIT_BRANCH_LOCAL)
                      (git-branch-create repo branch commit 1))
                    (let ((new-content? #f))
                      (set-range checkout-task (new Range 0 1))
                      (set-checkout-progress connection
                        (let ((inited? #f))
                          (lambda (error?)
                            ;; from a discusion on freenode, aborting a checkout could leave the worktree in an arbitrary
                            ;; state, but the next checkout force should overwrite whatever is present in the worktree...
                            ;; commented out as there is no way to interrupt the threaded checkout
                            ;; (safe-abort-point checkout-cleanup)
                            (git-checkout-state id
                              (lambda (completed-steps total-steps)
                                (when (> total-steps 0)
                                  (set! new-content? #t)
                                  (let ((remaining (- total-steps completed-steps)))
                                    (set-remaining checkout-task remaining))
                                  (when (not inited?)
                                    (set-range checkout-task (new Range 0 total-steps))
                                    (set! inited? #t))
                                  (set-pos checkout-task completed-steps)))))))
                      (set-checkout-done connection
                        (lambda (error?)
                          (unless (safe-abort-point checkout-cleanup)
                            (when error?
                              (git-error))
                            (set-done checkout-task)
                            (checkout-cleanup)
                            (cont new-content?))))
                      (let ((listener (open-stream-listener)))
                        (git-reset-hard-threaded id (get-write-file listener) repo commit)
                        (process-listener 'checkout listener (get-checkout-progress connection) (get-checkout-done connection)))))))))
          (git-remote-download-threaded id)
          (process-listener 'download listener (get-download-progress connection) (get-download-done connection)))))))


;;;
;;;; Remote
;;;


(class Password-Box extends Message-Box
  
  
  (method override (focus-box self)
    (acquire-focus (locate user-content 'password)))
  
  
  (method override (get-modal-result self)
    (get-string-content (locate user-content 'password))))


(class Password-Border extends Border-View
  
  
  (form
    (<install>                                 border-type: solid border-color: {Color Entry-Border}
      (<Scroller-View>          name: scroller hscroll?: #f vscroll?: #f
        (<!>                    name: content  layout-type: fill
          (<Password-Text-View> name: password return-press-handler: {Event-Handler :form on-return-press} escape-press-handler: {Event-Handler :form on-escape-press})))))
  
  
  (method override (on-return-press self evt)
    (process-action (child (get-guest self) 'yes) self))
  
  
  (method override (on-escape-press self evt)
    (process-action (child (get-guest self) 'cancel) self)))


(definition public (password-dialog)
  (let ((content (new Password-Border size: {Dimension 460 21})))
    (let ((password (locate content 'password))
          (code (catch (Cancel-Signal exc
                         'cancel)
                  (message-box
                    (or (jiri-password-message) `(<span> (<paragraph> "Please enter your password:")))
                    class: Password-Box
                    type: 'error
                    title: (or (jiri-password-title) "Password")
                    yes: (or (jiri-password-yes) "OK")
                    content: content
                    content-spacing: 2
                    sound: #f))))
      (and (eq? code 'yes)
           (get-string-content password)))))


(definition public (git-remote-connect-with-retries connection remote listener cancel (remote-exception? #f))
  (let ((password #f))
    (define (ask-password)
      (set! password (or (current-password) (password-dialog)))
      (or password
          (cancel-connection)))
    
    (define (cancel-connection)
      (if cancel
          (begin
            (set-cursor :arrow)
            (set-working? connection #f)
            (continuation-return cancel))
        (exit 1)))
    
    (let ((id (get-id connection))
          (fd (get-write-file listener))
          (callbacks
            (new Git-Callbacks
              credentials-callback: (lambda ()
                                      (git-cred-userpass-plaintext-new (jiri-username) (or (jiri-password) (ask-password))))))
          (max-tries 3))
      (let loop ((try 1))
        (if (> try max-tries)
            (exit 1)
          (catch (Git-Exception exc
                   (let ((err (get-message exc)))
                     (cond ((string-ends-with? err "401")
                            (message-box "Incorrect password")
                            (loop (+ try 1)))
                           (else
                            (if remote-exception?
                                (begin
                                  (set-cursor :arrow)
                                  (set-working? connection #f)
                                  (throw exc))
                              (system-message (if (jiri-devel?)
                                                  (string-append "Unable to connect to server (" (git-remote-url remote) "):\n\n" err)
                                                "Unable to connect to server")
                                              type: 'problem
                                              title: "Together")
                              (exit 1))))))
            (git-remote-connect remote GIT_DIRECTION_FETCH id fd callbacks)
            (current-password password)))))))


;;;
;;;; Quit
;;;


(definition public (quit-confirm-abort title)
  (lambda ()
    (if (not (work-in-progress?))
        (quit)
      (let ((code (message-box (string-append title " in progress.\n\nDo you want to abort?") type: 'question)))
        (when (eq? code 'yes)
          (request-quit "Aborting..."))))))


(definition public (quit-safely)
  (lambda ()
    (if (not (work-in-progress?))
        (quit)
      (request-quit "Disconnecting..."))))


(define (request-quit title)
  (set-abort-requested (lambda () (quit)))
  (git-request-abort)
  (set-title status-view title)
  (when minimize-view
    (set-enabled? minimize-view #f))
  (when close-view
    (set-enabled? close-view #f))))
