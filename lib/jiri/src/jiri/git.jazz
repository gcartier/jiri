;;;==============
;;;  JiriScheme
;;;==============
;;;
;;;; Git
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  See www.jazzscheme.org for details.


(module jiri.git jazz


(import (jazz.foreign)
        (jazz.git.foreign)
        (jazz.git.syntax (phase syntax))
        (jazz.platform)
        (jazz.platform.types))


(c-include "<git2.h>")


;;;
;;;; Error
;;;


(c-definition (jiri-git-call-error-handler error) (int) void "git_call_error_handler" ""
  (handle-git-error error))


;;;
;;;; Thread
;;;


(c-declare jiri.git #/C/
    #include <stdbool.h>
    
    bool abortRequested = false;
    
    // starting at 1000 is a hack around mac os x
    // sending a user callback 0 0 on window creation
    #define DOWNLOAD_PROGRESS 1000
    #define DOWNLOAD_DONE     1001
    #define CHECKOUT_PROGRESS 1002
    #define CHECKOUT_DONE     1003
//#)


(c-enumerant DOWNLOAD_PROGRESS)
(c-enumerant DOWNLOAD_DONE)
(c-enumerant CHECKOUT_PROGRESS)
(c-enumerant CHECKOUT_DONE)


(cond-expand
  (windows
(c-declare jiri.git #/C/
    HANDLE mutex = NULL;
    HWND hwnd = NULL;
    
    #define THREADPROC(name, payload) DWORD WINAPI name(LPVOID payload)
    
    void create_thread(LPTHREAD_START_ROUTINE proc, void* payload)
    {
        CreateThread(NULL, 0, proc, payload, 0, NULL);
    }
    
    void lock_mutex()
    {
        if (! mutex)
            mutex = CreateMutex(NULL, FALSE, NULL);
        WaitForSingleObject(mutex, INFINITE);
    }
    
    void unlock_mutex()
    {
        ReleaseMutex(mutex);
    }
    
    void post_notification(int what, int id, int result)
    {
        PostMessage(hwnd, WM_USER, what, MAKELPARAM(id, result));
    }
//#)

(c-external (discard-application-events) void
  #/C/
//#)

(c-external (git-callback-hwnd HWND) void
  #/C/
    hwnd = ___arg1;
//#))
  (else
(c-declare jiri.git #/C/
    #import <Cocoa/Cocoa.h>
    #include <pthread.h>
    
    pthread_mutex_t mutex;
    bool mutexInited = false;
    
    #define THREADPROC(name, payload) void* name(void* payload)
    
    typedef void*(*threadproc)(void*);
    
    void create_thread(threadproc proc, void* payload)
    {
        pthread_t thread;
        pthread_create(&thread, NULL, proc, payload);
    }
    
    void lock_mutex()
    {
        if (! mutexInited)
        {
            pthread_mutex_init(&mutex, NULL);
            mutexInited = true;
        }
        pthread_mutex_lock(&mutex);
    }
    
    void unlock_mutex()
    {
        pthread_mutex_unlock(&mutex);
    }
    
    #define MAKELPARAM(a,b)	((long)(((unsigned short)(a))|(((unsigned long)((unsigned short)(b)))<<16)))
    
    void post_notification(int what, int id, int result)
    {
        NSEvent* event;
        
        event = [NSEvent otherEventWithType:NSApplicationDefined
                                            location:NSMakePoint(0, 0)
                                       modifierFlags:0
                                           timestamp:0
                                        windowNumber:0
                                             context:nil
                                             subtype:0
                                               data1:what
                                               data2:MAKELPARAM(id, result)];
        [NSApp postEvent:event atStart:YES];
    }
//#)

(c-external (discard-application-events) void
  #/C/
    NSEvent* event;
    int what;
    
    do {
        event = [NSApp nextEventMatchingMask:NSApplicationDefinedMask
                                   untilDate:[NSDate distantPast]
                                      inMode:NSDefaultRunLoopMode
                                     dequeue:YES];
        what = [event data1];
        // we only discard the progress events so
        // repost any other and break out of loop
        if (what != DOWNLOAD_PROGRESS && what != CHECKOUT_PROGRESS)
        {
            [NSApp postEvent:event atStart:YES];
            break;
        }
    } while (event);
//#)

(c-external (git-callback-hwnd scheme-object) void
  #/C/
//#)))


(c-external (git-lock-mutex) void
  #/C/
    lock_mutex();
//#)

(c-external (git-unlock-mutex) void
  #/C/
    unlock_mutex();
//#)


(git-external (git-request-abort) void
  #/C/
    lock_mutex();
    abortRequested = true;
    unlock_mutex();
//#)


;;;
;;;; Checkout
;;;


(c-declare jiri.git #/C/
    #define MAX_CONNECTIONS 16
    
    git_repository* checkout_repository = NULL;
    
    struct CheckoutInfo
    {
        size_t checkout_completed_steps;
        size_t checkout_total_steps;
    };
    
    struct CheckoutInfo checkoutInfos[MAX_CONNECTIONS];
//#)

(git-external (git-checkout-completed-steps int) int
  #/C/
    ___return(checkoutInfos[___arg1].checkout_completed_steps);
//#)

(git-external (git-checkout-total-steps int) int
  #/C/
    ___return(checkoutInfos[___arg1].checkout_total_steps);
//#)

(definition public (git-checkout-state id proc)
  (git-lock-mutex)
  (let ((completed-steps (git-checkout-completed-steps id))
        (total-steps (git-checkout-total-steps id)))
    (git-unlock-mutex)
    (proc completed-steps total-steps)))

(c-declare jiri.git #/C/
    void checkout_callback(const char *path, size_t completed_steps, size_t total_steps, void *payload)
    {
        int id = *((int*)(&payload));
        lock_mutex();
        struct CheckoutInfo* info = &checkoutInfos[id];
        info->checkout_completed_steps = completed_steps;
        info->checkout_total_steps = total_steps;
        unlock_mutex();
        post_notification(CHECKOUT_PROGRESS, id, 0);
    }

    THREADPROC(checkout_head_proc, payload)
    {
        int id = *((int*)(&payload));
        git_checkout_options options = GIT_CHECKOUT_OPTIONS_INIT;
        options.checkout_strategy = GIT_CHECKOUT_FORCE;
        options.progress_cb = checkout_callback;
        options.progress_payload = payload;
        int result = git_checkout_head(checkout_repository, &options);
        post_notification(CHECKOUT_DONE, id, result);
        return 0;
    }
//#)

(git-external (git-checkout-head-force-threaded int git_repository*) void
  #/C/
    int id = ___arg1;
    checkout_repository = ___arg2;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wint-to-void-pointer-cast"
    create_thread(&checkout_head_proc, (void*) id);
#pragma GCC diagnostic pop
//#)

(c-declare jiri.git #/C/
    git_repository* reset_repository = NULL;
    git_object* reset_commit = NULL;
    
    THREADPROC(reset_hard_proc, payload)
    {
        int id = *((int*)(&payload));
        git_checkout_options options = GIT_CHECKOUT_OPTIONS_INIT;
        options.checkout_strategy = GIT_CHECKOUT_FORCE;
        options.progress_cb = checkout_callback;
        options.progress_payload = payload;
        int result = git_reset(reset_repository, reset_commit, GIT_RESET_HARD, &options);
        post_notification(CHECKOUT_DONE, id, result);
        return 0;
    }
//#)

(git-external (git-reset-hard-threaded int git_repository* git_object*) void
  #/C/
    int id = ___arg1;
    struct CheckoutInfo* info = &checkoutInfos[id];
    info->checkout_completed_steps = 0;
    info->checkout_total_steps = 0;
    reset_repository = ___arg2;
    reset_commit = ___arg3;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wint-to-void-pointer-cast"
    create_thread(&reset_hard_proc, (void*) id);
#pragma GCC diagnostic pop
//#)


;;;
;;;; Remote
;;;


(c-declare jiri.git #/C/
    struct DownloadInfo
    {
        git_remote* remote;
        unsigned int total_objects;
        unsigned int received_objects;
        size_t received_bytes;
    };
    
    struct DownloadInfo downloadInfos[MAX_CONNECTIONS];
//#)

(git-external (git-remote-download-total-objects int) int
  #/C/
    ___return(downloadInfos[___arg1].total_objects);
//#)

(git-external (git-remote-download-received-objects int) int
  #/C/
    ___return(downloadInfos[___arg1].received_objects);
//#)

(git-external (git-remote-download-received-bytes int) int
  #/C/
    ___return(downloadInfos[___arg1].received_bytes);
//#)

(definition public (git-download-state id proc)
  (git-lock-mutex)
  (let ((total-objects (git-remote-download-total-objects id))
        (received-objects (git-remote-download-received-objects id))
        (received-bytes (git-remote-download-received-bytes id)))
    (git-unlock-mutex)
    (proc total-objects received-objects received-bytes)))

(c-declare jiri.git #/C/
    int remote_download_callback(const git_transfer_progress *stats, void *payload)
    {
        int id = *((int*)(&payload));
        bool abort;
      
        lock_mutex();
        abort = abortRequested;
        downloadInfos[id].total_objects = stats->total_objects;
        downloadInfos[id].received_objects = stats->received_objects;
        downloadInfos[id].received_bytes = stats->received_bytes;
        unlock_mutex();
        
        if (! abort)
        {
            post_notification(DOWNLOAD_PROGRESS, id, 0);
            return 0;
        }
        else
            return -1;
    }

    THREADPROC(remote_download_proc, payload)
    {
        int id = *((int*)(&payload));
        git_remote* remote = downloadInfos[id].remote;
        git_remote_callbacks callbacks = GIT_REMOTE_CALLBACKS_INIT;
        callbacks.transfer_progress = remote_download_callback;
        callbacks.payload = payload;
        git_remote_set_callbacks(remote, &callbacks);
        int result = git_remote_download(remote, NULL);
        post_notification(DOWNLOAD_DONE, id, result);
        return 0;
    }
//#)

(git-external (git-remote-download-threaded int git_remote*) void
  #/C/
    int id = ___arg1;
    downloadInfos[id].remote = ___arg2;
    downloadInfos[id].total_objects = 0;
    downloadInfos[id].received_objects = 0;
    downloadInfos[id].received_bytes = 0;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wint-to-void-pointer-cast"
    create_thread(&remote_download_proc, (void*) id);
#pragma GCC diagnostic pop
//#))
