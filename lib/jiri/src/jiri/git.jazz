;;;==============
;;;  JiriScheme
;;;==============
;;;
;;;; Git Interface
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  See www.jazzscheme.org for details.


(module jiri.git jazz


(import (jazz.application)
        (jazz.component)
        (jazz.event)
        (jazz.git.foreign)
        (jazz.git.interface)
        (jazz.graphic)
        (jazz.handler)
        (jazz.listener)
        (jazz.markup)
        (jazz.platform)
        (jazz.text)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.view)
        (jazz.window)
        (jiri)
        (jiri.base)
        (jiri.manage)
        (jiri.settings)
        (jiri.structure)
        (jiri.window)
        (jiri.work))


;;;
;;;; Pull
;;;


(definition public (pull-repository section dir cont)
  (let ((title (get-title section))
        (connection (get-connection section)))
    (let ((id (get-id connection))
          (name (get-name connection))
          (url (get-url connection))
          (branch (get-branch connection))
          (download-task (get-download-task connection))
          (checkout-task (get-checkout-task connection))
          (listener (open-stream-listener))
          (new-content? #f))
      (define (open/init-repository proc)
        (let ((existing? (file-exists? dir)))
          (cond (existing?
                  (let ((repo (git-repository-open dir)))
                    (proc repo (git-remote-lookup repo "origin"))))
                (else
                 (let ((repo (git-repository-init dir)))
                   (proc repo (git-remote-create repo "origin" url)))))))
      
      (define (process-listener name listener progress done)
        (declare (proper-tail-calls))
        (let (loop)
          (let ((c (wait listener)))
            (case c
              ((#\.)
               (delay-event
                 (lambda ()
                   (progress #f)))
               (loop))
              ((#\@)
               (close-stream-listener listener)
               (done #f))
              ((#\!)
               (close-stream-listener listener)
               (done #t))))))
      
      (set-cursor :wait)
      (set-started? connection #t)
      (set-working? connection #t)
      (set-status download-task (string-append "Downloading " title))
      (open/init-repository
        (lambda (repo remote)
          (define download-progress
            (let ((inited? #f))
              (lambda (error?)
                (git-download-state id
                  (lambda (total-objects received-objects received-bytes)
                    (set! new-content? #t)
                    (let ((downloaded (fxfloor (/ (exact->inexact received-bytes) (* 1024. 1024.))))
                          (remaining (- total-objects received-objects)))
                      (set-downloaded download-task downloaded)
                      (set-remaining download-task remaining))
                    (when (not inited?)
                      (set-range download-task (new Range 0 total-objects))
                      (set! inited? #t))
                    (set-pos download-task received-objects))))))
          
          (define download-done
            (lambda (error?)
              (unless (safe-abort-point
                        (lambda ()
                          (git-remote-disconnect remote)
                          (git-remote-free remote)
                          (git-repository-free repo)
                          (set-cursor :arrow)
                          (set-working? connection #f)))
                (when error?
                  (check-git-current-error))
                (set-status checkout-task (string-append "Installing " title))
                (set-done download-task)
                (git-remote-disconnect remote)
                (git-remote-update-tips remote)
                (git-remote-free remote)
                (git-repository-set-head repo (string-append "refs/heads/" branch))
                (let ((upstream (git-reference-lookup repo (string-append "refs/remotes/origin/" branch))))
                  (let ((commit (git-object-lookup repo (git-reference->id repo upstream) GIT_OBJ_COMMIT)))
                    (define (checkout-cleanup)
                      (git-reference-free upstream)
                      (git-object-free commit)
                      (git-repository-free repo)
                      (set-cursor :arrow)
                      (set-working? connection #f))
                    
                    (define checkout-progress
                      (let ((inited? #f))
                        (lambda (error?)
                          ;; from a discusion on freenode, aborting a checkout could leave the worktree in an arbitrary
                          ;; state, but the next checkout force should overwrite whatever is present in the worktree...
                          ;; commented out as there is no way to interrupt the threaded checkout
                          ;; (safe-abort-point checkout-cleanup)
                          (git-checkout-state id
                            (lambda (completed-steps total-steps)
                              (when (> total-steps 0)
                                (let ((remaining (- total-steps completed-steps)))
                                  (set-remaining checkout-task remaining))
                                (when (not inited?)
                                  (set-range checkout-task (new Range 0 total-steps))
                                  (set! inited? #t))
                                (set-pos checkout-task completed-steps)))))))
                    
                    (define checkout-done
                      (lambda (error?)
                        (unless (safe-abort-point checkout-cleanup)
                          (when error?
                            (check-git-current-error))
                          (set-done checkout-task)
                          (checkout-cleanup)
                          (cont new-content?))))
                    
                    (unless (git-branch-lookup repo branch GIT_BRANCH_LOCAL)
                      (git-branch-create repo branch commit 1))
                    (set-range checkout-task (new Range 0 1))
                    (let ((listener (open-stream-listener)))
                      (git-reset-hard-threaded id (get-write-file listener) repo commit)
                      (process-listener 'checkout listener checkout-progress checkout-done)))))))
          
          (connect-with-credentials connection remote listener)
          (set-range download-task (new Range 0 1))
          (git-remote-download-threaded id)
          (process-listener 'download listener download-progress download-done))))))


;;;
;;;; Remote
;;;


(definition public (connect-with-credentials connection remote listener)
  (let ((id (get-id connection))
        (fd (get-write-file listener))
        (callbacks
          (new Git-Callbacks
            credentials-callback: (let ((first-attempt? #t))
                                    (lambda ()
                                      (if first-attempt?
                                          (begin
                                            (set! first-attempt? #f)
                                            (git-cred-userpass-plaintext-new (jiri-username) (jiri-password)))
                                        #f))))))
    (git-remote-connect remote GIT_DIRECTION_FETCH id fd callbacks)))


;;;
;;;; Quit
;;;


(definition public (quit-safely)
  (lambda ()
    (if (not (work-in-progress?))
        (quit)
      (request-quit "Disconnecting..."))))


(define (request-quit title)
  (set-abort-requested (lambda () (quit)))
  (git-request-abort)
  (set-title status-view title)
  (when minimize-view
    (set-enabled? minimize-view #f))
  (when close-view
    (set-enabled? close-view #f))))
