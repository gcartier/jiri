;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Git
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jiri.git jazz


(import (jazz.foreign)
        (jazz.git.foreign)
        (jazz.git.syntax (phase syntax))
        (jazz.platform)
        (jazz.platform.types))


(c-include "<git2.h>")


;;;
;;;; Error
;;;


(c-definition (git-check-error error-code) (int) void "git_check_error" ""
  (when (not (= error-code 0))
    (throw (let ((err (giterr-last)))
             (if err
                 (new Git-Exception error-code (git-error-message err))
               (new Git-Exception error-code #f))))))


;;;
;;;; Thread
;;;


(cond-expand
  (windows
(c-declare jiri.git #/C/
    #include <stdbool.h>
    
    HANDLE mutex = NULL;
    HWND hwnd = NULL;
    
    #define THREADPROC(name, payload) DWORD WINAPI name(LPVOID payload)
    
    void create_thread(LPTHREAD_START_ROUTINE proc, void* payload)
    {
        CreateThread(NULL, 0, proc, payload, 0, NULL);
    }
    
    void lock_mutex()
    {
        if (! mutex)
            mutex = CreateMutex(NULL, FALSE, NULL);
        WaitForSingleObject(mutex, INFINITE);
    }
    
    void unlock_mutex()
    {
        ReleaseMutex(mutex);
    }
    
    void post_notification(int what, int result)
    {
        PostMessage(hwnd, WM_USER, what, result);
    }
//#)

(c-external (git-callback-hwnd HWND) void
  #/C/
    hwnd = ___arg1;
//#))
  (else
(c-declare jiri.git #/C/
    #import <Cocoa/Cocoa.h>
    #include <pthread.h>
    
    pthread_mutex_t mutex;
    bool mutexInited = false;
    
    #define THREADPROC(name, payload) void* name(void* payload)
    
    typedef void*(*threadproc)(void*);
    
    void create_thread(threadproc proc, void* payload)
    {
        pthread_t thread;
        pthread_create(&thread, NULL, proc, payload);
    }
    
    void lock_mutex()
    {
        if (! mutexInited)
        {
            pthread_mutex_init(&mutex, NULL);
            mutexInited = true;
        }
        pthread_mutex_lock(&mutex);
    }
    
    void unlock_mutex()
    {
        pthread_mutex_unlock(&mutex);
    }
    
    void post_notification(int what, int result)
    {
        NSEvent* event = [NSEvent otherEventWithType:NSApplicationDefined
                                            location:NSMakePoint(0, 0)
                                       modifierFlags:0
                                           timestamp:0
                                        windowNumber:0
                                             context:nil
                                             subtype:0
                                               data1:what
                                               data2:result];
        [NSApp postEvent:event atStart:YES];
    }
//#)

(c-external (git-callback-hwnd scheme-object) void
  #/C/
//#)))


(c-declare jiri.git #/C/
    bool quitRequested = false;
    
    #define DOWNLOAD_PROGRESS 0
    #define DOWNLOAD_DONE     1
    #define CHECKOUT_PROGRESS 2
    #define CHECKOUT_DONE     3
    #define UPDATING_GAME     5
//#)


(c-enumerant DOWNLOAD_PROGRESS)
(c-enumerant DOWNLOAD_DONE)
(c-enumerant CHECKOUT_PROGRESS)
(c-enumerant CHECKOUT_DONE)
(c-enumerant UPDATING_GAME)


(c-external (git-lock-mutex) void
  #/C/
    lock_mutex();
//#)

(c-external (git-unlock-mutex) void
  #/C/
    unlock_mutex();
//#)


(git-external (git-request-quit) void
  #/C/
    lock_mutex();
    quitRequested = true;
    unlock_mutex();
//#)


;;;
;;;; Checkout
;;;


(c-declare jiri.git #/C/
    git_repository* checkout_repository = NULL;
    
    char* checkout_path = NULL;
    size_t checkout_completed_steps = 0;
    size_t checkout_total_steps = 0;
//#)

(git-external (git-checkout-path) char-string
  #/C/
    ___result = checkout_path;
//#)

(git-external (git-checkout-completed-steps) int
  #/C/
    ___result = checkout_completed_steps;
//#)

(git-external (git-checkout-total-steps) int
  #/C/
    ___result = checkout_total_steps;
//#)

(definition public (git-checkout-state proc)
  (git-lock-mutex)
  (let ((path (git-checkout-path))
        (completed-steps (git-checkout-completed-steps))
        (total-steps (git-checkout-total-steps)))
    (git-unlock-mutex)
    (proc path completed-steps total-steps)))

(c-declare jiri.git #/C/
    void checkout_callback(const char *path, size_t completed_steps, size_t total_steps, void *payload)
    {
        lock_mutex();
        checkout_path = (char*) path;
        checkout_completed_steps = completed_steps;
        checkout_total_steps = total_steps;
        unlock_mutex();
        post_notification(CHECKOUT_PROGRESS, 0);
    }

    THREADPROC(checkout_head_proc, payload)
    {
        git_checkout_options options = GIT_CHECKOUT_OPTIONS_INIT;
        options.checkout_strategy = GIT_CHECKOUT_FORCE;
        options.progress_cb = checkout_callback;
        int result = git_checkout_head(checkout_repository, &options);
        post_notification(CHECKOUT_DONE, result);
        return 0;
    }
//#)

(git-external (git-checkout-head-force-threaded git_repository*) void
  #/C/
    checkout_repository = ___arg1;
    create_thread(&checkout_head_proc, NULL);
//#)


;;;
;;;; Remote
;;;


(c-declare jiri.git #/C/
    unsigned int total_objects = 0;
    unsigned int received_objects = 0;
    size_t received_bytes = 0;
//#)

(git-external (git-remote-download-total-objects) int
  #/C/
    ___result = total_objects;
//#)

(git-external (git-remote-download-received-objects) int
  #/C/
    ___result = received_objects;
//#)

(git-external (git-remote-download-received-bytes) int
  #/C/
    ___result = received_bytes;
//#)

(definition public (git-download-state proc)
  (git-lock-mutex)
  (let ((total-objects (git-remote-download-total-objects))
        (received-objects (git-remote-download-received-objects))
        (received-bytes (git-remote-download-received-bytes)))
    (git-unlock-mutex)
    (proc total-objects received-objects received-bytes)))

(c-declare jiri.git #/C/
    int remote_download_callback(const git_transfer_progress *stats, void *payload)
    {
        bool quit;
      
        lock_mutex();
        quit = quitRequested;
        total_objects = stats->total_objects;
        received_objects = stats->received_objects;
        received_bytes = stats->received_bytes;
        unlock_mutex();
        
        if (! quit)
        {
            post_notification(DOWNLOAD_PROGRESS, 0);
            return 0;
        }
        else
            return -1;
    }

    THREADPROC(remote_download_proc, payload)
    {
        git_remote* remote = (git_remote*) payload;
        git_remote_callbacks callbacks = GIT_REMOTE_CALLBACKS_INIT;
        callbacks.transfer_progress = remote_download_callback;
        git_remote_set_callbacks(remote, &callbacks);
        int result = git_remote_download(remote, NULL);
        post_notification(DOWNLOAD_DONE, result);
        return 0;
    }
//#)

(git-external (git-remote-download-threaded git_remote*) void
  #/C/
    create_thread(&remote_download_proc, ___arg1);
//#))
