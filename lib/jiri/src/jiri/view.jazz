;;;==============
;;;  JiriScheme
;;;==============
;;;
;;;; View
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  See www.jazzscheme.org for details.


(module jiri.view jazz


(import (jazz.application)
        (jazz.cairo)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.image)
        (jazz.jml)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (jiri.font)
        (jiri.manage)
        (jiri.settings)
        (jiri.window))


(definition protected jiri-pane
  #f)

(definition public (set-jiri-pane pane)
  (set! jiri-pane pane))


(definition public (add-view view)
  (unless (get-parent~ view)
    (set-parent~ view jiri-pane)
    (invalidate-view~ view)))


(definition public (remove-view view)
  (set-parent~ view #f)
  (invalidate-view~ view))


;;;
;;;; Skin
;;;


@skin-convert
(class Jiri-Skin extends Jazz-Skin
  
  
  (form
    (<install>                          title: "Jiri"
      (<!>     name: menu               background: {Color White} highlight: {Gradient vertical {Color red: .588 green: .000 blue: .000} {Color red: .196 green: .000 blue: .000}} text-font: {Font Label point-size: 24} text-color: {Color Red} disabled-text-color: {Color red: .522 green: .506 blue: .427})
      (<!>     name: scrollbar          background: none)
      (<!>     name: scrollbar/tool     background: none)
      (<!>     name: scrollbar/document background: none)
      (<!>     name: tree               background: none line-color: {Color White} text-color: {Color White} focused-color: {Gradient vertical {Color red: 180 green: 0 blue: 0} {Color red: 250 green: 0 blue: 0}} unfocused-color: {Gradient vertical {Color red: 180 green: 0 blue: 0} {Color red: 250 green: 0 blue: 0}}))))


;;;
;;;; Background
;;;


(definition cached-background
  #f)


(definition public (cache-background)
  (when (not cached-background)
    (let ((background (jiri-background)))
      (assert background
        (set! cached-background (load-image background)))))
  cached-background)


(definition public (cache-background-size)
  (let ((background (cache-background)))
    (new Dimension
      (cairo_image_surface_get_width background)
      (cairo_image_surface_get_height background))))


;;;
;;;; Root
;;;


(class Jiri-Root extends View
  
  
  (method override (draw surface context)
    (draw-surface~ surface (cache-background) 0 0)
    (when (jiri-dark-overlay?)
      (let ((rect (get-bounds)))
        (gradient-fill-rect~ surface (new Rect (get-left~ rect) (- (get-bottom~ rect) 350) (get-right~ rect) (get-bottom~ rect)) (list (list 0 {Color Black alpha: 0.}) (list 1 {Color Black})) direction: 'vertical))))
  
  
  (method override (cursor-update evt)
    (set-cursor (if (work-in-progress?) :wait :arrow))))


;;;
;;;; Title
;;;


(class Jiri-Title extends View
  
  
  (cond-expand
    (windows
     (slot cursor-pos initialize #f getter generate)
     (slot window-pos initialize #f getter generate)
     (slot moving?    initialize #f getter generate))
    (else))
  
  
  (method override (draw surface context)
    (set-font~ surface default-title-font)
    (draw-text~ surface 0 0 title {Color White}))
  
  
  (cond-expand
    (windows
     (method override (cursor-update evt)
       (set-cursor :all))

     (method override (mouse-down evt)
       (set! cursor-pos (to-desktop (get-position~ evt)))
       (set! window-pos (get-position~ (get-toplevel)))
       (set! moving? #t)
       (acquire-capture))
     
     (method override (drag-move evt)
       (when moving?
         (let ((current (to-desktop (get-position~ evt))))
           (let ((delta (nu- current cursor-pos)))
             (let ((pos (nu+ window-pos delta)))
               (set-position~ (get-toplevel) pos))))))

     (method override (mouse-up evt)
       (when moving?
         (release-capture)
         (set! moving? #f))))
    (else)))


;;;
;;;; Label
;;;


(class Jiri-Label extends Label-View
  
  
  (form
    (<install> color: {Color White})))


;;;
;;;; Button
;;;


(class Jiri-Button extends View
  
  
  (property action  initialize #f accessors generate)
  (property active? initialize #t accessors generate)
  
  
  (method override (draw surface context)
    (let ((bounds (get-bounds)))
      (if (and enabled? active? (eq? self (mouse-view)))
          (fill-rect~ surface bounds {Color red: 230 green: 0 blue: 0})
        (gradient-fill-rect~ surface bounds
          (list (list 0 (if enabled? {Color red: 150 green: 0 blue: 0} {Color White}))
                (list 1 (if enabled? {Color red: 220 green: 0 blue: 0} {Color White})))
          direction: 'horizontal)))
    (set-font~ surface default-button-font)
    (when title
      (let ((pos (justify-lazy (lambda () (get-text-extent~ surface title))
                               (lambda () (get-size))
                               'center)))
        (draw-text~ surface (get-h~ pos) (get-v~ pos) title (if enabled? {Color White} {Color red: 160 green: 160 blue: 160})))))
  
  
  (method override (cursor-update evt)
    (if active?
        (set-cursor :arrow)
      (set-cursor (if (work-in-progress?) :wait :arrow))))
  
  
  (method override (mouse-enter)
    (invalidate-view))
  
  
  (method override (mouse-leave)
    (invalidate-view))
  
  
  (method override (mouse-up evt)
    (when (and enabled? active?)
      (process-action self))))


;;;
;;;; Tree
;;;


(class Jiri-Tree extends Layout-View
  
  
  (form
    (<install>                                       background: {Color red: .000 green: .000 blue: .000 alpha: .2} layout-type: fill
      (<Border-View>                                 border-type: edge style: entry
        (<Scroller-View>                             vscroll?: #t
          (<content~>                                layout-type: fill
            (<Jiri-Tree-View>      name: tree        background: #f filled-column: environment font: {Font Label-User point-size: 18} default-row-height: 25 can-select-empty?: #f selection-handler: {Selection-Handler :form on-selection-change}
              (<Tree-Node-Column>  name: environment toplevel-controls?: #f display-images?: #f))))))))


(class Jiri-Tree-View extends Tree-View)


;;;
;;;; Close
;;;


(class Jiri-Close extends Jiri-Button
  
  
  (method override (draw surface context)
    (let ((rect (get-bounds)))
      (let ((left (+ (get-left~ rect) 6))
            (top (+ (get-top~ rect) 6))
            (right (- (get-right~ rect) 6))
            (bottom (- (get-bottom~ rect) 6)))
        (define (draw-x width color)
          (set-line-width~ surface width)
          (set-color~ surface color)
          (line~ surface left top right bottom)
          (line~ surface right top left bottom))
        
        @not-needed (draw-x 4. {Color red: 150 green: 150 blue: 150})
        (draw-x 2. (if (eq? self (mouse-view)) {Color red: 200 green: 0 blue: 0} {Color red: 255 green: 255 blue: 255})))))
  
  
  (method override (process-action sender (properties (action-properties)))
    (quit-callback)))


;;;
;;;; Minimize
;;;


(class Jiri-Minimize extends Jiri-Button
  
  
  (method override (draw surface context)
    (let ((rect (get-bounds)))
      (let ((left (+ (get-left~ rect) 6))
            (top (+ (get-top~ rect) 6))
            (right (- (get-right~ rect) 6))
            (bottom (- (get-bottom~ rect) 6)))
        (define (draw-line width color)
          (set-line-width~ surface width)
          (set-color~ surface color)
          (line~ surface left (- bottom 1) right (- bottom 1)))
        
        @not-needed (draw-line 4. {Color red: 150 green: 150 blue: 150})
        (draw-line 2. (if (eq? self (mouse-view)) {Color red: 200 green: 0 blue: 0} {Color red: 255 green: 255 blue: 255})))))
  
  
  (method override (process-action sender (properties (action-properties)))
    (minimize~ (get-toplevel))))


;;;
;;;; Progress
;;;


(class Jiri-Progress extends View
  
  
  (method override (draw surface context)
    (let ((rect (get-bounds)))
      (fill-rect~ surface rect {Color White})
      (let ((left (get-left~ rect))
            (top (get-top~ rect))
            (right (get-right~ rect))
            (bottom (get-bottom~ rect))
            (width (rect-width rect))
            (head {Color red: 150 green: 0 blue: 0})
            (tail {Color red: 220 green: 0 blue: 0}))
        (for-each-task-info
          (lambda (task step from to)
            (let ((l (+ left (fxfloor (* width from))))
                  (r (+ left (fxceiling (* width to)))))
              (let ((r (+ l (fxceiling (* (- r l) (progress-done~ task))))))
                (with-clip~ surface (new Rect l top r bottom)
                  (lambda ()
                    (gradient-fill-rect~ surface (new Rect left top right bottom)
                      (list (list 0 head)
                            (list 1 tail))
                      direction: 'horizontal))))))))))))
